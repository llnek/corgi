
(defn Motions "" [options]
  `{:state options
    :inited false
    ;this.netplay = engine.getNodeList(gnodes.NetPlayNode);
    ;this.gui = engine.getNodeList(gnodes.GUINode);
    :evQ [] })

(defn onceOnly "" [sys]
  (let [ws sys.state.wsock
        t ? m ? s ?]
    (when ws
      (.cancelAll ws)
      (.listenAll ws (fn [msg]
          (obj.onNext {group:'net', event: msg}))))
    ;sh.main.signal('/touch/one/end', msg => obj.onNext(msg));
    ;sh.main.signal('/mouse/up', msg => obj.onNext(msg));
    ;this.stream.subscribe( msg => { if (!!this.evQ) { this.evQ.push(msg); }
    ))

(defn update "" [dt]
  (let [evt this.evQ.length > 0 ? this.evQ.shift() : undef,
    n= this.netplay.head,
    g= this.gui.head;

    if (!this.inited) {
      this.onceOnly();
      this.inited=true;
    }
    else if (!!evt) {
      if (evt.group === 'net') {
        if (!!n) { this.onnet(n, evt.event); }
      } else {
        if (!!g) { this.ongui(g,evt); }
      }
    }
  },
  /**
   * @method onnet
   * @private
   */
  onnet(node, evt) {
    switch (evt.type) {
      case evts.MSG_NETWORK:
        this.onnetw(node, evt);
      break;
      case evts.MSG_SESSION:
        this.onsess(node, evt);
      break;
    }
  },
  /**
   * @method onnetw
   * @private
   */
  onnetw(node, evt) {
    switch (evt.code) {
      case evts.RESTART:
        sjs.loggr.debug("restarting a new game...");
        sh.fire('/net/restart');
      break;
      case evts.STOP:
        if (this.state.running) {
          sjs.loggr.debug("game will stop");
          sh.fire('/hud/timer/hide');
          this.onsess(node,evt);
          sh.fire('/net/stop', evt);
        }
      break;
    }
  },
  /**
   * @method onsess
   * @private
   */
  onsess(node, evt) {
    let cmd= evt.source.cmd,
    snd, pnum,
    grid=node.grid,
    vs=grid.values;

    if (sjs.isobj(cmd) &&
        sjs.isnum(cmd.cell) &&
        cmd.cell >= 0 &&
        cmd.cell < vs.length) {

      if (this.state.players[1].value === cmd.value) {
        snd= 'x_pick';
      } else {
        snd= 'o_pick';
      }
      vs[cmd.cell] = cmd.value;
      sh.sfxPlay(snd);
    }

    pnum= sjs.isnum(evt.source.pnum) ? evt.source.pnum : -1;
    if (pnum === 1 || pnum === 2) {} else { return; }
    switch (evt.code) {
      case evts.POKE_MOVE:
        sjs.loggr.debug("player " + pnum + ": my turn to move");
        sh.fire('/hud/timer/show');
        this.state.actor= pnum;
      break;
      case evts.POKE_WAIT:
        sjs.loggr.debug("player " + pnum + ": my turn to wait");
        sh.fire('/hud/timer/hide');
        // toggle color
        this.state.actor= pnum===1 ? 2 : 1;
      break;
    }
  },
  /**
   * @method ongui
   * @private
   */
  ongui(node, evt) {
    if (!this.state.running) {return;}
    let sel = node.selection,
    map = node.view.gridMap,
    rect,
    sz= map.length;

    //set the mouse/touch position
    sel.px = evt.loc.x;
    sel.py = evt.loc.y;
    sel.cell= -1;

    if (this.state.actor === 0) {
      return;
    }

    //which cell did he click on?
    for (let n=0; n < sz; ++n) {
      rect = map[n];
      if (sel.px >= rect.left && sel.px <= rect.right &&
          sel.py >= rect.bottom && sel.py <= rect.top) {
        sel.cell= n;
        break;
      }
    }
  }

}


