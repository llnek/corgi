
(defn posToAnchors! "" [node where]
  (with-local-vars
    [[hw hh] (ccsx/csize_2 node)
     [cx cy] (ccsz/center)
     B (ccsx/vbox)
     [x y]
     (condp = where
       (.-Bottom *anchors*) [cx (+ B.bottom hh)]
       (.-Center *anchors*) [cx cy]
       (.-Top *anchors*) [cx (- B.top hh)]
       (.-BottomRight *anchors*) [(- B.right hw) (+ B.bottom hh)]
       (.-Right *anchors*) [(- B.right hw) cy]
       (.-TopRight *anchors*) [(- B.right hw) (- B.top hh)]
       (.-BottomLeft *anchors*) [(+ B.left hw) (+ B.bottom hh)]
       (.-Left *anchors*) [(+ B.left hw) cy]
       (.-TopLeft *anchors*) [(+ B.left hw) (- B.top hh)])])
  (if (number? x)
    (pos! node x y)))

(defn hudLayer "" [zOrder]
  (with-local-vars [y (xlayer)
                    wz= ccsx.vbox()])
  (.attr y `{:color (cc/color "#5e3178")
             :idTag :HUD
             :p2Long  "" :p1Long "" :p2ID "" :p1ID ""})
  (set! menu (ccsx/gmenu1
               `{:nnn "#icon_menu.png"
                 :cb #(signal "hud.showmenu")} ))
  (posToAnchors menu (.-BottomRight *anchors*))
  (child+ y menu zOrder)

  (set! menu (ccsx/gmenu1
               `{:nnn "#icon_replay.png"
                 :cb #(signal "hud.replay")}))
  (posToAnchors menu (.-BottomLeft *anchors*))
  (hide! menu)
  (child+ y menu zOrder)
  ;this.scores= {};
  ;this.scores[csts.P2_COLOR] =  0;
  ;this.scores[csts.P1_COLOR] =  0;
  (set! title (sprite "#title.png"))
  (posToAnchor title  (.-Top *anchors*))
  (child+ y title)

  (set! score1 (bmfLabel "0" "font.SmallTypeWriting"))
  (posToAnchor! score1 (.-TopLeft *anchors*))
  (child+ y score1 0)

  (set! score2 (bmfLabel "0" "font.SmallTypeWriting"))
  (posToAnchor! score2 (.-TopRight *anchors*))
  (child+ y score2 0)

  (set! status (bmfLabel "" "font.CoffeeBuzzed"))
  (posToAnchors! status (.-Bottom *anchors*))
  (child+ y status)

  (set! result (bmfLabel "" "font.CoffeeBuzzed"))
  (posToAnchors! result (.-Bottom *anchors*))
  (hide! result)
  (child+ y result))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn showTimer "" [node]
  ;;timer is already showing, go away
  (when-not node.countDownState?
    (when-not node.countDown
      (set! obj (bmfLabel "" "font.AutoMission"))
      (pos! obj cw.x wb.top - 10*csts.TILE)
      (child+ node obj 0 :countDown)))
    (oset! node :countDownValue  csts.PLAYER_THINK_TIME)
    (showCountDown)
    (.schedule node updateTimer 1.0)
    (true! this.countDownState))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn updateTimer "" [dt]
  (when-not node.countDownState?
    (oset! node
           :countDownValue (-1 node.countDownValue))
    (if (neg? node.countDownValue)
      (do (killTimer) (signal "player.timer.expired"))
      (showCountDown))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn showCountDown "" [msg]
  (if-some [node (.getChildByName node :countDown)])
      (.setString node (or msg (numStr node.countDownValue))))

(defn killTimer "" []
  (when node.countDownState?
    (.unschedule node updateTimer) (showCountDown ""))
  (oset! node :countDownState #f :countDownValue 0))

(defn updateScore "" [pcolor value]
  (oset! node.scores pcolor (+ (oget node.scores pcolor) value))
  (drawScores))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn update "" [running? pnum]
  (if running? (drawStatus pnum) (drawResult pnum)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn endGame "" [node winner]
  (killTimer)
  (show! (.getChildByName node :replay))
  (show! (.getChildByName node :result))
  (hide! (.getChildByName node :status))
  (drawResult winner))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn drawStatusText "" [obj msg] (.setString obj (or msg "")))

(defn drawScores "" [node]
  (with-local-vars [s2  (oget node.scores node.play2)
                    s1 (oget node.scores node.play1)])
  (.setString (.getChildByName node :score2 (numStr s2)))
  (.setString (.getChildByName node :score1 (numStr s1))))


(defn drawResult "" [pnum]
 (->> (condp = pnum
        2  (l10n "%whowin" `{:who node.p2Long})
        1  (l10n "%whowin" `{:who node.p1Long})
        (l10n "%whodraw"))
      (drawStatusText (.getChildByName node :result))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn drawStatus "" [pnum]
  (if (number? pnum)
    (->> `{:who (if (= 1 pnum) node.p1Long node.p2Long)}
         (l10n "%whosturn")
         (drawStatusText (.getChildByName node :status)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn regoPlayers "" [color1 p1ids color2 p2ids]
  (.attr node
         `{:play2 color2
           :play1 color1
           :p2Long (_2 p2ids)
           :p1Long (_2 p1ids)
           :p2ID (_1 p2ids)
           :p1ID (_1 p1ids)})
  (.setString (.getChildByName node :title )
              (str node.p1ID " / " node.p2ID)))

(defn resetAsNew "" [] (initScores) (reset))


(defn reset "" []
    (hide! (.getChildByName node :replay))
    (hide! (.getChildByName node :result))
    (show! (.getChildByName node :status)))


