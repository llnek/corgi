
(defn posToAnchors "" [node where]
  (with-local-vars
    [[hw hh] (ccsx/csize_2 node)
     [cx cy] (ccsz/center)
     B (ccsx/vbox)
     [x y]
     (condp = where
       (.-Bottom *anchors*) [cx (+ B.bottom hh)]
       (.-Center *anchors*) [cx cy]
       (.-Top *anchors*) [cx (- B.top hh)]
       (.-BottomRight *anchors*) [(- B.right hw) (+ B.bottom hh)]
       (.-Right *anchors*) [(- B.right hw) cy]
       (.-TopRight *anchors*) [(- B.right hw) (- B.top hh)]
       (.-BottomLeft *anchors*) [(+ B.left hw) (+ B.bottom hh)]
       (.-Left *anchors*) [(+ B.left hw) cy]
       (.-TopLeft *anchors*) [(+ B.left hw) (- B.top hh)])])
  (if (number? x)
    (pos! node x y)))

(defn hudLayer "" [zOrder]
  (with-local-vars [y (xlayer)
                    wz= ccsx.vbox()])
  (.attr y `{:color (cc/color "#5e3178")
             :idTag :HUD
             :p2Long  "" :p1Long "" :p2ID "" :p1ID ""})
  (set! menu (ccsx/gmenu1
               `{:nnn "#icon_menu.png"
                 :cb #(signal "hud.showmenu")} ))
  (posToAnchors menu (.-BottomRight *anchors*))
  (child+ y menu zOrder)

  (set! menu (ccsx/gmenu1
               `{:nnn "#icon_replay.png"
                 :cb #(signal "hud.replay")}))
  (posToAnchors menu (.-BottomLeft *anchors*))
  (hide! menu)
  (child+ y menu zOrder)
  ;this.scores= {};
  ;this.scores[csts.P2_COLOR] =  0;
  ;this.scores[csts.P1_COLOR] =  0;
  (set! title (sprite "#title.png"))
  (posToAnchor title  (.-Top *anchors*))
  (child+ y title)

  (set! score1 (bmfLabel "0" "font.SmallTypeWriting"))
  (posToAnchor! score1 (.-TopLeft *anchors*))
  (child+ y score1 0)

  (set! score2 (bmfLabel "0" "font.SmallTypeWriting"))
  (posToAnchor! score2 (.-TopRight *anchors*))
  (child+ y score2 0)

  (set! status (bmfLabel "" "font.CoffeeBuzzed"))
  (posToAnchors! status (.-Bottom *anchors*))
  (child+ y status)

  (set! result (bmfLabel "" "font.CoffeeBuzzed"))
  (posToAnchors! result (.-Bottom *anchors*))
  (hide! result)
  (child+ y result))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn showTimer "" [node]
  ;;timer is already showing, go away
  (when-not node.countDownState?
    if (! this.countDown) {
      this.countDown= ccsx.bmfLabel({
        fontPath: sh.getFont('font.AutoMission'),
        text: '',
        scale: xcfg.game.scale * 0.5,
        color: ccsx.white,
        pos: cc.p(cw.x,
                  wb.top - 10*csts.TILE),
        anchor: ccsx.acs.Center
      });
      this.addItem(this.countDown);
    }

    this.countDownValue= csts.PLAYER_THINK_TIME;
    this.showCountDown();

    this.schedule(this.updateTimer, 1.0);
    this.countDownState= true;
  },
  /**
   * @method updateTimer
   * @private
   */
  updateTimer(dt) {
    if (!this.countDownState) { return; } else {
      this.countDownValue -= 1;
    }
    if (this.countDownValue < 0) {
      this.killTimer();
      sh.fire('/player/timer/expired');
    }
    else {
      this.showCountDown();
    }
  },
  /**
   * @method showCountDown
   * @private
   */
  showCountDown(msg) {
    if (!!this.countDown) {
      this.countDown.setString(msg || '' + this.countDownValue);
    }
  },
  /**
   * @method killTimer
   * @private
   */
  killTimer() {
    if (this.countDownState) {
      this.unschedule(this.updateTimer);
      this.showCountDown(' ');
    }
    this.countDownState=false;
    this.countDownValue=0;
  },
  /**
   * @method updateScore
   * @private
   */
  updateScore(pcolor, value) {
    this.scores[pcolor] += value;
    this.drawScores();
  },
  /**
   * @method update
   * @protected
   */
  update(running, pnum) {
    if (running) {
      this.drawStatus(pnum);
    } else {
      this.drawResult(pnum);
    }
  },
  /**
   * @method endGame
   * @private
   */
  endGame(winner) {
    this.killTimer();
    this.replayBtn.setVisible(true);
    this.result.setVisible(true);
    this.status.setVisible(false);
    this.drawResult(winner);
  },
  /**
   * @method drawStatusText
   * @private
   */
  drawStatusText(obj, msg) {
    obj.setString(msg || '');
  },
  /**
   * @method drawScores
   * @private
   */
  drawScores() {
    const s2 = this.scores[this.play2],
    s1 = this.scores[this.play1],
    n2 = ''+s2,
    n1 = ''+s1;

    this.score1.setString(n1);
    this.score2.setString(n2);
  },
  /**
   * @method drawResult
   * @private
   */
  drawResult(pnum) {
    let msg = sh.l10n('%whodraw');

    if (sjs.isnum(pnum)) {
      switch (pnum) {
        case 2: msg= sh.l10n('%whowin', { who: this.p2Long}); break;
        case 1: msg= sh.l10n('%whowin', { who: this.p1Long}); break;
      }
    }

    this.drawStatusText(this.result, msg);
  },
  /**
   * @method drawStatus
   * @private
   */
  drawStatus(pnum) {
    if (sjs.isnum(pnum)) {
      const pfx = pnum === 1 ? this.p1Long : this.p2Long;
      this.drawStatusText(this.status,
                          sh.l10n('%whosturn', {
        who: pfx
      }));
    }
  },
  /**
   * @method regoPlayers
   * @private
   */
  regoPlayers(color1,p1ids,color2,p2ids) {
    this.play2= color2;
    this.play1= color1;
    this.p2Long= p2ids[1];
    this.p1Long= p1ids[1];
    this.p2ID= p2ids[0];
    this.p1ID= p1ids[0];
    this.title.setString(this.p1ID + " / " + this.p2ID);
  },
  /**
   * @method resetAsNew
   * @protected
   */
  resetAsNew() {
    this.initScores();
    this.reset();
  },
  /**
   * @method reset
   * @protected
   */
  reset() {
    this.replayBtn.setVisible(false);
    this.result.setVisible(false);
    this.status.setVisible(true);
  }
});


