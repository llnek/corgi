
(const *Events*
       `{;;Msg types
         :MSG_NETWORK           1
         :MSG_SESSION           2
         :PLAYGAME_REQ          3
         :JOINGAME_REQ          4
         :PLAYREQ_NOK         10
         :JOINREQ_NOK         11
         :USER_NOK            12
         :GAME_NOK            13
         :ROOM_NOK            14
         :ROOM_FILLED         15
         :ROOMS_FULL          16

         :PLAYREQ_OK          30
         :JOINREQ_OK          31

         :AWAIT_START         40
         :SYNC_ARENA          45
         :POKE_RUMBLE         46

         :RESTART             50
         :START               51
         :STOP                52
         :POKE_MOVE           53
         :POKE_WAIT           54
         :PLAY_MOVE           55
         :REPLAY              56
         :QUIT_GAME           60
         :PLAYER_JOINED       90
         :STARTED             95
         :CONNECTED           98
         :ERROR               99
         :CLOSED              100

         :S_NOT_CONNECTED       0
         :S_CONNECTED           1 })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkEvent "" [eventType code payload]
  `{:timeStamp  (Date/now)
    :type eventType
    :code code
    :source payload })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkPlayRequest "" [game user pwd]
  (mkEvent (.-PLAYGAME_REQ *Events*) -1 [game user pwd]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mkJoinRequest "" [room user pwd]
  (mkEvent (.-JOINGAME_REQ *Events*) -1 [room user pwd]))

(defn- getPlayRequest "" [options]
  (jsonfy (mkPlayRequest options.game
                         options.user options.passwd)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn json_decode "" [e]
  (with-local-vars [evt (try (objectfy e.data) (catch _e `{})) src ?])
  (if-not (contains? evt :type) (oset! evt :type -1))
  (if-not (contains? evt :code) (oset! evt :code -1))
  (if (and (contains? evt :source)
           (string? evt.source))
    (oset! evt :source (objectfy evt.source)))
  evt)

(defcc Session cc/Class
  `{connection #(.wsock this %)
    ctor (fn [config]
           (._super this)
           (oset! this
                  :handlers []
                  :ws nil
                  :options (or config `{})
                  :ebus (ebus/reifyRvBus)
                  :state (.-S_NOT_CONNECTED *Events*)))
    send (fn [evt]
           (if (and (= @@state  (.-S_CONNECTED *Events*))
                    (some? @@ws))
             (.send @@ws (jsonfy evt))))
    listen (fn [msgType evt cb ctx]
             (with-local-vars
               [h (.on @@ebus (str msgType "." evt) cb ctx)])
             (if (not-empty h)
               ;;store the handle ids for clean up
               (conj! @@handlers (_1 h)))
             (_1 h))
    listenAll (fn [cb ctx]
                [(listen (.-MSG_NETWORK *Events*) "*" cb ctx)
                 (listen (.-MSG_SESSION *Events*) "*" cb ctx)])
    cancelAll (fn []
                (.removeAll @@ebus)
                (oset! this :handlers []))
    cancel (fn [subid]
             (removeItem! @@handlers subid)
             (.off @@ebus subid))
    reset (fn []
            (oset! this
                   :onmessage *nulfunc*
                   :onerror *nulfunc*
                   :onclose *nulfunc*
                   :handlers [])
            (.removeAll @@ebus))
    close (fn []
            (oset! this :state (.-S_NOT_CONNECTED *Events*))
            (.reset this)
            (if @@ws (trye! (.close @@ws)))
            (oset! this :ws nil))
    disconnect #(.close this)
    onNetworkMsg (fn [evt])
    onSessionMsg (fn [evt])
    wsock (fn [url]
            (with-local-vars [me this
                              ws (new WebSocket url)])
            ;;connection success, send the play game request
            (oset! this :ws ws)
            (oset! ws
                   :open (fn []
                           (oset! me :state (.-S_CONNECTED *Events*))
                           (.send ws (getPlayRequest me.options)))
                   :onmessage (fn [e]
                                (with-local-vars [evt (json_decode e)])
                                (condp = e.type
                                  (.-MSG_NETWORK *Events*) (.onevent me e)
                                  (.-MSG_SESSION *Events*) (.onevent me e)
                                  (loggr/warn
                                    "unhandled server event: "
                                    e.type ", code = " e.code)))
                   :onclose (fn [e]
                              (loggr/debug "closing websocket."))
                   :onerror (fn [e]
                              (loggr/debug "websocket error.\n" e)))
            ws)
    onevent (fn [evt]
              (.fire @@ebus
                     (str evt.type "." evt.code) evt)) })


