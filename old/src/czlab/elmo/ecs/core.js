/*Auto generated by Kirby v1.0.0 - Sat Mar 31 2018 19:30:39 GMT-0700 (PDT)
  czlab.elmo.ecs.core
{"doc" "" "author" "Kenneth Leung"}
*/

const R__1 = require("kirby");
const MODULE_NAMESPACE = R__1["MODULE_NAMESPACE"];
const MAX_DASH_INT = R__1["MAX_DASH_INT"];
const MIN_DASH_INT = R__1["MIN_DASH_INT"];
const println = R__1["println"];
const not_DASH_empty = R__1["not_DASH_empty"];
const stringify = R__1["stringify"];
const opt_QMRK__QMRK = R__1["opt_QMRK__QMRK"];
const cons_BANG = R__1["cons_BANG"];
const conj_BANG = R__1["conj_BANG"];
const conj = R__1["conj"];
const disj_BANG = R__1["disj_BANG"];
const disj = R__1["disj"];
const pop_BANG = R__1["pop_BANG"];
const pop = R__1["pop"];
const wrap_DASH_str = R__1["wrap_DASH_str"];
const getIndex = R__1["getIndex"];
const getProp = R__1["getProp"];
const prn = R__1["prn"];
const LambdaArg = R__1["LambdaArg"];
const Primitive = R__1["Primitive"];
const RegexObj = R__1["RegexObj"];
const Keyword = R__1["Keyword"];
const Symbol = R__1["Symbol"];
const primitive_QMRK = R__1["primitive_QMRK"];
const primitive = R__1["primitive"];
const regexObj_QMRK = R__1["regexObj_QMRK"];
const regexObj = R__1["regexObj"];
const symbol_QMRK = R__1["symbol_QMRK"];
const symbol = R__1["symbol"];
const keyword_QMRK = R__1["keyword_QMRK"];
const keyword = R__1["keyword"];
const keyword_DASH__GT_symbol = R__1["keyword_DASH__GT_symbol"];
const lambdaArg_QMRK = R__1["lambdaArg_QMRK"];
const lambdaArg = R__1["lambdaArg"];
const Atom = R__1["Atom"];
const atom_QMRK = R__1["atom_QMRK"];
const atom = R__1["atom"];
const reset_BANG = R__1["reset_BANG"];
const resetVec_BANG = R__1["resetVec_BANG"];
const resetMap_BANG = R__1["resetMap_BANG"];
const resetSet_BANG = R__1["resetSet_BANG"];
const resetObject_BANG = R__1["resetObject_BANG"];
const objClass = R__1["objClass"];
const sort_BANG = R__1["sort_BANG"];
const deref = R__1["deref"];
const swap_BANG = R__1["swap_BANG"];
const typeid = R__1["typeid"];
const complex_QMRK = R__1["complex_QMRK"];
const simple_QMRK = R__1["simple_QMRK"];
const value_QMRK = R__1["value_QMRK"];
const sequential_QMRK = R__1["sequential_QMRK"];
const eq_QMRK = R__1["eq_QMRK"];
const object_QMRK = R__1["object_QMRK"];
const last = R__1["last"];
const into_BANG = R__1["into_BANG"];
const into = R__1["into"];
const pairs_QMRK = R__1["pairs_QMRK"];
const list_QMRK = R__1["list_QMRK"];
const list = R__1["list"];
const vector_QMRK = R__1["vector_QMRK"];
const vector = R__1["vector"];
const set_QMRK = R__1["set_QMRK"];
const set = R__1["set"];
const map_QMRK = R__1["map_QMRK"];
const obj_QMRK = R__1["obj_QMRK"];
const arraymap = R__1["arraymap"];
const object = R__1["object"];
const seq = R__1["seq"];
const rseq = R__1["rseq"];
const contains_QMRK = R__1["contains_QMRK"];
const nichts_QMRK = R__1["nichts_QMRK"];
const some_QMRK = R__1["some_QMRK"];
const count = R__1["count"];
const concat_STAR = R__1["concat_STAR"];
const evens = R__1["evens"];
const odds = R__1["odds"];
const modulo = R__1["modulo"];
const partition = R__1["partition"];
const split = R__1["split"];
const split_DASH_str = R__1["split_DASH_str"];
const interleave = R__1["interleave"];
const zipmap = R__1["zipmap"];
const zipobj = R__1["zipobj"];
const extendAttr = R__1["extendAttr"];
const cons = R__1["cons"];
const gensym = R__1["gensym"];
const carve = R__1["carve"];
const assoc_BANG = R__1["assoc_BANG"];
const dissoc_BANG = R__1["dissoc_BANG"];
const truthy_QMRK = R__1["truthy_QMRK"];
const falsy_QMRK = R__1["falsy_QMRK"];
const flatten = R__1["flatten"];
const identity = R__1["identity"];
const m_DASH_identity = R__1["m_DASH_identity"];
const m_DASH_maybe = R__1["m_DASH_maybe"];
const m_DASH_list = R__1["m_DASH_list"];
const m_DASH_state = R__1["m_DASH_state"];
const m_DASH_continuation = R__1["m_DASH_continuation"];
const run_DASH_cont = R__1["run_DASH_cont"];
const quote_DASH_str = R__1["quote_DASH_str"];
const unquote_DASH_str = R__1["unquote_DASH_str"];
const escXml = R__1["escXml"];
const split_DASH_seq = R__1["split_DASH_seq"];
const select_DASH_keys = R__1["select_DASH_keys"];
const update_DASH_in_BANG = R__1["update_DASH_in_BANG"];
const get_DASH_in = R__1["get_DASH_in"];
const merge = R__1["merge"];
const mixin = R__1["mixin"];
const fillArray = R__1["fillArray"];
const copyArray = R__1["copyArray"];
const difference = R__1["difference"];
const inc = R__1["inc"];
const dec = R__1["dec"];
const percent = R__1["percent"];
const toFixed = R__1["toFixed"];
const mapcat = R__1["mapcat"];
const ensureTest = R__1["ensureTest"];
const ensureTestThrown = R__1["ensureTestThrown"];
const runtest = R__1["runtest"];
const pushNSP = R__1["pushNSP"];
const popNSP = R__1["popNSP"];
const peekNSP = R__1["peekNSP"];
const _STAR_ns_STAR = R__1["_STAR_ns_STAR"];
const minBy = R__1["minBy"];
const maxBy = R__1["maxBy"];
const take_DASH_while = R__1["take_DASH_while"];
const drop_DASH_while = R__1["drop_DASH_while"];
const split_DASH_with = R__1["split_DASH_with"];
const kirbystdlibref = require("kirby");
const __module_namespace__ = "czlab.elmo.ecs.core";
////////////////////////////////////////////////////////////////////////////////
//fn: [createPool] in file: core.ky, line: 15
const createPool = function(ctor, init, batch) {
  if ( (!(((typeof (ctor) === "function")) && ((typeof (init) === "function")))) ) {
    throw Error("Precondition failed");
  } else {
    null;
  }
  return atom({
    "size": 0,
    "next": 0,
    "slots": [],
    "ctor": ctor,
    "init": init,
    "batch": batch
  });
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getPoolSize] in file: core.ky, line: 22
const getPoolSize = function(pool) {
  return kirbystdlibref.getProp(pool.value, "size");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getPoolUsed] in file: core.ky, line: 25
const getPoolUsed = function(pool) {
  return kirbystdlibref.getProp(pool.value, "next");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [takeFromPool] in file: core.ky, line: 28
const takeFromPool = function(pool) {
  let co = undefined;
  let ret = null;
  swap_BANG(pool, function(root) {
    let size = kirbystdlibref.getProp(root, "size");
    let next = kirbystdlibref.getProp(root, "next");
    let slots = kirbystdlibref.getProp(root, "slots");
    let batch = kirbystdlibref.getProp(root, "batch");
    let ctor = kirbystdlibref.getProp(root, "ctor");
    if ( (next >= size) ) {
      for (let ____coll = null, x = 0, ____end = batch, ____break = false; ((!____break) && (x < ____end)); x = (x + 1)) {
        (
        co = ctor());
        conj_BANG(slots, co);
        (
        co["____pool"] = pool);
      }
      (root["size"] = (batch + size));
    }
    (ret = slots[next]);
    (ret["____status"] = true, ret["____slot"] = next);
    (
    root["next"] = (next + 1));
    return root;
  });
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [returnToPool] in file: core.ky, line: 46
const returnToPool = function(pool, obj) {
  if ( (!(nichts_QMRK(obj) || (obj.____pool !== pool))) ) {
    swap_BANG(pool, function(root) {
      let init = kirbystdlibref.getProp(root, "init");
      let next = kirbystdlibref.getProp(root, "next");
      let slots = kirbystdlibref.getProp(root, "slots");
      if (kirbystdlibref.getProp(obj, "____status")) {
        (
        root["next"] = (next - 1));
        init(obj);
        let tail = slots[root.next];
        let slot_QUOT = kirbystdlibref.getProp(tail, "____slot");
        let epos_QUOT = kirbystdlibref.getProp(obj, "____slot");
        (slots[root.next] = obj, slots[epos_QUOT] = tail);
        (
        tail["____slot"] = epos_QUOT);
        (obj["____slot"] = slot_QUOT, obj["____status"] = false);
      }
      return root;
    });
  } else {
    null;
  }
  return pool;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createECS] in file: core.ky, line: 67
const createECS = function() {
  return atom((new Map([["entities",(new Set([]))], ["templates",(new Map([]))], ["registry",(new Map([]))], ["data",(new Map([]))], ["systems", []], ["uid", 1]])));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [genUid] in file: core.ky, line: 75
const genUid = function(ecs) {
  let ret = 0;
  swap_BANG(ecs, function(root) {
    let uid = kirbystdlibref.getProp(root, "uid");
    (
    ret = uid);
    return (kirbystdlibref.assoc_BANG(root, "uid", (uid + 1)));
  });
  return ["e@", ret].join("");
};
////////////////////////////////////////////////////////////////////////////////
//fn: [retUsed] in file: core.ky, line: 83
const retUsed = function(obj) {
  return (((Object.prototype.toString.call(obj) === "[object Map]")) ?
    retUsed(Array.from(obj.values())) :
    ((Array.isArray(obj)) ?
      obj.forEach(function(c) {
        return ((c && c.____pool) ?
          returnToPool(c.____pool, c) :
          null);
      }) :
      (object_QMRK(obj) ?
        (obj.____pool ?
          returnToPool(obj.____pool, obj) :
          null) :
        null)));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createEntity] in file: core.ky, line: 96
const createEntity = function(ecs, componentId) {
  let moreIds = Array.prototype.slice.call(arguments, 2);
  return (function() {
    let entity = genUid(ecs);
    addToEntity.apply(this, [ecs, entity].concat(componentId, moreIds));
    swap_BANG(ecs, function(root) {
      let entities = kirbystdlibref.getProp(root, "entities");
      conj_BANG(entities, entity);
      return root;
    });
    return entity;
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeEntity] in file: core.ky, line: 107
const removeEntity = function(ecs, entity) {
  let more = Array.prototype.slice.call(arguments, 2);
  let c = undefined;
  let ents = [entity].concat(more);
  swap_BANG(ecs, function(root) {
    let entities = kirbystdlibref.getProp(root, "entities");
    let data = kirbystdlibref.getProp(root, "data");
    let registry = kirbystdlibref.getProp(root, "registry");
    Array.from(registry.keys()).forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return (function() {
        let GS__8 = kirbystdlibref.getProp(data, ____args[0]);
        let co = GS__8;
        return ((((typeof (GS__8) === "undefined")) || ((GS__8 === null))) ?
          null :
          ents.forEach(function(e) {
            retUsed(kirbystdlibref.getProp(co, e));
            return kirbystdlibref.dissoc_BANG(co, e);
          }));
      }).call(this);
    });
    ents.forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return disj_BANG(entities, ____args[0]);
    });
    return root;
  });
  return ecs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addComponent] in file: core.ky, line: 120
const addComponent = function(ecs, id, component) {
  let more = Array.prototype.slice.call(arguments, 3);
  swap_BANG(ecs, function(root) {
    let registry = kirbystdlibref.getProp(root, "registry");
    partition(2, [id, component].concat(more)).forEach(function(GS__10) {
      let a = kirbystdlibref.getIndex(GS__10, 0);
      let b = kirbystdlibref.getIndex(GS__10, 1);
      return (kirbystdlibref.assoc_BANG(registry, a, b));
    });
    return root;
  });
  return ecs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeComponent] in file: core.ky, line: 128
const removeComponent = function(ecs, id) {
  let more = Array.prototype.slice.call(arguments, 2);
  swap_BANG(ecs, function(root) {
    let data = kirbystdlibref.getProp(root, "data");
    let registry = kirbystdlibref.getProp(root, "registry");
    [id].concat(more).forEach(function(c) {
      kirbystdlibref.dissoc_BANG(registry, c);
      retUsed(kirbystdlibref.getProp(data, c));
      return kirbystdlibref.dissoc_BANG(data, c);
    });
    return root;
  });
  return ecs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addToEntity] in file: core.ky, line: 137
const addToEntity = function(ecs, entity, componentId) {
  let moreIds = Array.prototype.slice.call(arguments, 3);
  swap_BANG(ecs, function(root) {
    let data = kirbystdlibref.getProp(root, "data");
    let registry = kirbystdlibref.getProp(root, "registry");
    let ctor = null;
    let co = null;
    [componentId].concat(moreIds).forEach(function(cid) {
      (
      ctor = kirbystdlibref.getProp(registry, cid));
      if ( (!ctor) ) {
        throw new Error(["Unknown component ", cid].join(""));
      } else {
        null;
      }
      if ( (!data.has(cid)) ) {
        (kirbystdlibref.assoc_BANG(data, cid, (new Map([]))));
      } else {
        null;
      }
      (co = ctor());
      (
      co["____entity"] = entity);
      return (kirbystdlibref.assoc_BANG(kirbystdlibref.getProp(data, cid), entity, co));
    });
    return root;
  });
  return entity;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeFromEntity] in file: core.ky, line: 151
const removeFromEntity = function(ecs, entity) {
  let componentIds = Array.prototype.slice.call(arguments, 2);
  swap_BANG(ecs, function(root) {
    let data = kirbystdlibref.getProp(root, "data");
    componentIds.forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return (function() {
        let GS__14 = kirbystdlibref.getProp(data, ____args[0]);
        let co = GS__14;
        return ((!(((typeof (GS__14) === "undefined")) || ((GS__14 === null)))) ?
          (function() {
            retUsed(kirbystdlibref.getProp(co, entity));
            return kirbystdlibref.dissoc_BANG(co, entity);
          }).call(this) :
          null);
      }).call(this);
    });
    return root;
  });
  return entity;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getEntityData] in file: core.ky, line: 159
const getEntityData = function(ecs, entity, componentId) {
  let d = kirbystdlibref.getProp(ecs.value, "data");
  let c = kirbystdlibref.getProp(d, componentId);
  return (c ?
    kirbystdlibref.getProp(c, entity) :
    undefined);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [updateEntity] in file: core.ky, line: 165
const updateEntity = function(ecs, entity, componentId, func) {
  swap_BANG(ecs, function(root) {
    let data = kirbystdlibref.getProp(root, "data");
    let GS__16 = getEntityData(ecs, entity, componentId);
    let c = GS__16;
    if ( (((typeof (GS__16) === "undefined")) || ((GS__16 === null))) ) {
      null;
    } else {
      func(c);
    }
    return root;
  });
  return entity;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getComponentsData] in file: core.ky, line: 172
const getComponentsData = function(ecs, componentId) {
  let d = kirbystdlibref.getProp(ecs.value, "data");
  return (function() {
    let GS__17 = kirbystdlibref.getProp(d, componentId);
    let c = GS__17;
    return ((((typeof (GS__17) === "undefined")) || ((GS__17 === null))) ?
      [] :
      Array.from(c.values()));
  }).call(this);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getComponentKeys] in file: core.ky, line: 177
const getComponentKeys = function(ecs) {
  return Array.from(kirbystdlibref.getProp(ecs.value, "registry").keys());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [findComponent] in file: core.ky, line: 180
const findComponent = function(ecs, componentId) {
  return kirbystdlibref.getProp(kirbystdlibref.getProp(ecs.value, "registry"), componentId);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [componentInEntity?] in file: core.ky, line: 184
const componentInEntity_QMRK = function(ecs, entity, componentId) {
  let moreIds = Array.prototype.slice.call(arguments, 3);
  let d = kirbystdlibref.getProp(ecs.value, "data");
  return (!([componentId].concat(moreIds) || []).some(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (function() {
      let GS__18 = kirbystdlibref.getProp(d, ____args[0]);
      let co = GS__18;
      return ((((typeof (GS__18) === "undefined")) || ((GS__18 === null))) ?
        true :
        (!co.has(entity)));
    }).call(this);
  }));
};
////////////////////////////////////////////////////////////////////////////////
//fn: [findEntities] in file: core.ky, line: 191
const findEntities = function(ecs, componentId) {
  let moreIds = Array.prototype.slice.call(arguments, 2);
  let pmks = undefined;
  let ccsz = undefined;
  let eid = undefined;
  let cnt = undefined;
  let c = undefined;
  let sum = undefined;
  let GS__19 = ecs.value;
  let data = kirbystdlibref.getProp(GS__19, "data");
  let entities = kirbystdlibref.getProp(GS__19, "entities");
  let pmin = MAX_DASH_INT;
  let missed_QMRK = false;
  let pm = null;
  let ccs = [];
  let ret = [];
  let cids = [componentId].concat(moreIds);
  for (let ____coll = cids, ____index = 0, ____end = kirbystdlibref.count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
    let cid = ____coll[____index];
    (c = kirbystdlibref.getProp(data, cid), cnt = count(c));
    if (nichts_QMRK(c)) {
      (
      missed_QMRK = true);
      (
      ____break = true);
    } else {
      if ( (cnt < pmin) ) {
        (pmin = cnt, pm = c);
      }
      conj_BANG(ccs, c);
    }
  }
  (ccsz = kirbystdlibref.count(ccs));
  if ( ((ccsz > 0) && (!missed_QMRK)) ) {
    (
    pmks = Array.from(pm.keys()));
    for (let GS__22 = 0, GS__20 = true, GS__21 = pmks, ____sz = kirbystdlibref.count(GS__21), ____break = false; (!____break && GS__20 && (GS__22 < ____sz)); ++GS__22) {
      let eid = GS__21[GS__22];
      let sum = 0;
      for (let GS__25 = 0, GS__23 = true, GS__24 = ccs, ____sz = kirbystdlibref.count(GS__24), ____break = false; (!____break && GS__23 && (GS__25 < ____sz)); ++GS__25) {
        let c = GS__24[GS__25];
        if ( (c === pm) ) {
          ++sum;
        } else {
          if (c.has(eid)) {
            ++sum;
          }
        }
      }
      if ( (sum === ccsz) ) {
        conj_BANG(ret, e);
      }
    }
  }
  return ret;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addTemplate] in file: core.ky, line: 224
const addTemplate = function(ecs, id, template) {
  let more = Array.prototype.slice.call(arguments, 3);
  swap_BANG(ecs, function(root) {
    let templates = kirbystdlibref.getProp(root, "templates");
    partition(2, [id, template].concat(more)).forEach(function(GS__27) {
      let a = kirbystdlibref.getIndex(GS__27, 0);
      let b = kirbystdlibref.getIndex(GS__27, 1);
      return (kirbystdlibref.assoc_BANG(templates, a, b));
    });
    return root;
  });
  return ecs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [getTemplateKeys] in file: core.ky, line: 233
const getTemplateKeys = function(ecs) {
  return Array.from(kirbystdlibref.getProp(ecs.value, "templates").keys());
};
////////////////////////////////////////////////////////////////////////////////
//fn: [findTemplate] in file: core.ky, line: 236
const findTemplate = function(ecs, templateId) {
  return kirbystdlibref.getProp(kirbystdlibref.getProp(ecs.value, "templates"), templateId);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeTemplate] in file: core.ky, line: 240
const removeTemplate = function(ecs, id) {
  let moreIds = Array.prototype.slice.call(arguments, 2);
  swap_BANG(ecs, function(root) {
    let templates = kirbystdlibref.getProp(root, "templates");
    [id].concat(moreIds).forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return kirbystdlibref.dissoc_BANG(templates, ____args[0]);
    });
    return root;
  });
  return ecs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [createTemplateEntity] in file: core.ky, line: 247
const createTemplateEntity = function(ecs, id) {
  let entity = null;
  swap_BANG(ecs, function(root) {
    let templates = kirbystdlibref.getProp(root, "templates");
    let t = kirbystdlibref.getProp(templates, id);
    (entity = createEntity.apply(this, [ecs].concat(seq(t.components))));
    if (( (typeof (t.initor) === "function") )) {
      t.initor(ecs, entity);
    }
    return root;
  });
  return entity;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [addSystem] in file: core.ky, line: 260
const addSystem = function(ecs, system) {
  let more = Array.prototype.slice.call(arguments, 2);
  if ( (!(((typeof (system) === "function")))) ) {
    throw Error("Precondition failed");
  } else {
    null;
  }
  swap_BANG(ecs, function(root) {
    let systems = kirbystdlibref.getProp(root, "systems");
    [system].concat(more).forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return conj_BANG(systems, ____args[0]);
    });
    return root;
  });
  return ecs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [removeSystem] in file: core.ky, line: 268
const removeSystem = function(ecs, system) {
  let more = Array.prototype.slice.call(arguments, 2);
  swap_BANG(ecs, function(root) {
    let systems = kirbystdlibref.getProp(root, "systems");
    [system].concat(more).forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return (function() {
        let i = systems.indexOf(____args[0]);
        return ((!((i < 0))) ?
          systems.splice(i, 1) :
          null);
      }).call(this);
    });
    return root;
  });
  return ecs;
};
////////////////////////////////////////////////////////////////////////////////
//fn: [updateECS] in file: core.ky, line: 277
const updateECS = function(ecs, dt) {
  kirbystdlibref.getProp(ecs.value, "systems").forEach(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return ____args[0](ecs, dt);
  });
  return ecs;
};
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.elmo.ecs.core",
    vars: ["createPool", "getPoolSize", "getPoolUsed", "takeFromPool", "returnToPool", "createECS", "createEntity", "removeEntity", "addComponent", "removeComponent", "addToEntity", "removeFromEntity", "getEntityData", "updateEntity", "getComponentsData", "getComponentKeys", "findComponent", "componentInEntity?", "findEntities", "addTemplate", "getTemplateKeys", "findTemplate", "removeTemplate", "createTemplateEntity", "addSystem", "removeSystem", "updateECS"],
    macros: {}
  },
  createPool: createPool,
  getPoolSize: getPoolSize,
  getPoolUsed: getPoolUsed,
  takeFromPool: takeFromPool,
  returnToPool: returnToPool,
  createECS: createECS,
  createEntity: createEntity,
  removeEntity: removeEntity,
  addComponent: addComponent,
  removeComponent: removeComponent,
  addToEntity: addToEntity,
  removeFromEntity: removeFromEntity,
  getEntityData: getEntityData,
  updateEntity: updateEntity,
  getComponentsData: getComponentsData,
  getComponentKeys: getComponentKeys,
  findComponent: findComponent,
  componentInEntity_QMRK: componentInEntity_QMRK,
  findEntities: findEntities,
  addTemplate: addTemplate,
  getTemplateKeys: getTemplateKeys,
  findTemplate: findTemplate,
  removeTemplate: removeTemplate,
  createTemplateEntity: createTemplateEntity,
  addSystem: addSystem,
  removeSystem: removeSystem,
  updateECS: updateECS
};