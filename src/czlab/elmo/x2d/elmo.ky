;; Copyright Â©  2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.elmo.x2d.core

;import Mustache from "mustache";
;;import LZString from "eligrey/l10njs";
;import Ash from "ash-js";
  (:require ["kirby" :refer :all]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- *seed* 0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; monkey patch logger to use cocos2d's log functions.
(def *logger* cc)
(def *loggr* cc)
(oset! *loggr* :info cc/log :debug  cc/log)
(*loggr*/info "Monkey patched loggr to cc.log")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn l10nInit "" [table]
  (LZString/toLocaleString table)
  (oset! LZString
         :defaultLocale "en"
         :locale cc/sys.language)
  (loggr/info "Loaded l10n strings.  locale = " LZString.locale))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn l10n "" [s & pms]
  (with-local-vars [t (.toLocaleString s)])
  (if (empty? pms) t (Mustache/render t pms)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn fire "" [topic msg]
  (if-some [r (.getRunningScene cc/director)]
    (.fire r.ebus topic (or msg `{}))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getLevelCfg "" [level]
  (get-in *xcfg* [:levels (str level) "cfg"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isIntersect? "" [a1 a2]
  (not (or (> a1.left a2.right)
           (> a2.left a1.right)
           (< a1.top a2.bottom)
           (< a2.top a1.bottom))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn outOfBound? "" [a B]
  (if (and a B)
      (or (> a.left B.right)
          (< a.top B.bottom)
          (< a.right B.left)
          (> a.bottom B.top))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn calcXY "" [angle hypot]
  (with-local-vars [theta ? x ? y ? q ?])
  ;;quadrants =  4 | 1
  ;;             --|--
  ;;             3 | 2
  (cond
    (and (>= angle 0)(<= angle 90))
    (set! theta (degToRad (- 90 angle))
          x (Math/cos theta) y (Math/sin theta) q 1)
    (and (>= angle 90)(<= angle 180 ))
    (set! theta (degToRad (- angle 90))
          y (- (Math/sin theta)) x (Math/cos theta) q 2)
    (and (>= angle 180)(<= angle 270))
    (set! theta (degToRad (- 270 angle))
          x (- (Math/cos theta)) y (- (Math/sin theta)) q 3)
    :else
    (and (>= angle 270)(<= angle 360))
    (set! theta (degToRad (- angle 270))
          x (- (Math/cos theta)) y (Math/sin theta) q 4))
  [ (* x hypot) (* y hypot) q ])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn normalizeDeg
  "Normalize the degree - modulo 360." [deg]
  (cond (> deg 360)
        (modulo deg 360)
        (< deg 0)
        (+ 360 (modulo deg 360)) :else deg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hh
  "Divide the height of the rectangle by half." [r] (* 0.5 r.height))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hw
  "Divide the width of the rectangle by half." [r] (* 0.5 r.width))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn radToDeg
  "Convert from radian to degree." [rad] (* 180 (/ rad Math/PI)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn degToRad
  "Convert from degree to radian." [deg] (* deg (/ Math/PI 180)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getImage
  "Get the image path mapped to this key." [key]
  (fixUrl (get-in *xcfg* [:assets :images key])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getPList
  "Get the *atlas* plist mapped to this key." [key]
  (fixUrl (get-in *xcfg* [:assets :plists key])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getSfx
  "Get the sound file path mapped to this key."
  [key] (fixUrl (get-in [:assets :sounds key])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getTiles
  "Get the *tile* file path mapped to this key."
  [key] (fixUrl (get-in *xcfg* [:assets :tiles key])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getFont
  "Get the *font* file path mapped to this key."
  [key]
  (fixUrl (get-in *xcfg* [:assets :fonts key])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn toggleSfx "" [override?]
  "Toggle sound on or off.  Override by forcing a value."
  (update-in! *xcfg*
              [:sound :open?]
              #(if override? override? (not %))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxPlayMusic
  "Play music mapped to this key, repeat if necessary."
  [key & [options]]
  (set! options (opt?? options `{}))
  (when (get-in *xcfg* [:sound :open?])
    (sfxMusicVol options.vol)
    (.playMusic cc/audioEngine
                (getSfx key) (true? options.repeat))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxPlay
  "Play sound effect mapped to this key, repeat if necessary."
  [key & [options]]
  (set! options (opt?? options `{}))
  (when (get-in *xcfg* [:sound :open?])
    (sfxMusicVol options.vol)
    (.playEffect cc/audioEngine
                 (getSfx key) (true? options.repeat))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxMusicVol
  "Set Music volume." [v]
  (if (and (number? v)
           (get-in *xcfg* [:sound :open?])) (.setMusicVolume cc/audioEngine v)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxCancel
  "Cancel all sounds." []
  (.stopAllEffects cc/audioEngine) (.stopMusic cc/audioEngine))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sfxInit
  "Initialize the sound system." []
  (update-in! *xcfg* [:sound :open?] #(true))
  (sfxMusicVol (get-in *xcfg* [:sound :volume])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- fixUrl
  "Sanitize this url differently for web and for devices."
  [url]
  (loggr/debug "About to sanitize url: " url)
  (with-local-vars [rc (if cc/sys.isNative
                         (sanitizeUrlForDevice url)
                         (sanitizeUrlForWeb url))])
  (loggr/debug "Sanitized url: " rc)
  rc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sanitizeUrlForDevice
  "Sanitize this url for devices."
  [url]
  (cond
    (.match url #/^res\//)
    (if (contains? url "/sfx/")
      (let [ss (.split url "/")
            t (nth ss 1)]
        (aset ss 1 "sfx" 2 t)
        (set! url (join  "/" ss)))
      (set! url (.slice url 4)))
    (.match url #/^game/)
    (set! url (str "src" (.slice url 4))))
  (Mustache/render url
                   `{"border-tiles" (get-in *xcfg* [:game :borderTiles])
                     "lang" (get-in *xcfg* [:game :lang])
                     "color" (get *xcfg* :color)
                     "appid" (get *xcfg* :appid) }))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sanitizeUrlForWeb
  "Sanitize this url for web." [url]

  ;;ensure we tell mustache not to escape html
  (cond
    (.match url #/^game/)
    (set! url (str "{{{gamesource-ref}}}/" url))
    (.match url #/^res/)
    (set! url (str "{{{media-ref}}}/" url)))
  (Mustache/render url `{"border-tiles" (get-in *xcfg* [:game :borderTiles])
                         "gamesource-ref" "/public/elmo/lib"
                         "media-ref" "/public/elmo"
                         "lang" (get-in *xcfg* [:game :lang])
                         "color" (get *xcfg* :color)
                         "appid" (get *xcfg* :appid) }))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn throttle
  "Throttle this function, with some delay.
   (from underscore.js)
   @param {Function} func
   @param {Number} wait
   @param {Object} options
   @return {Function} wrapped function."
  [func wait & [options]]

  (with-local-vars [context ? args ? result ?
                    later ? timeout nil previous 0])
  (set! options (opt?? options `{}))
  (set! later
        (fn []
          (set! previous (if (false? options.leading) 0 (nowMillis)))
          (set! timeout nil)
          (set! result (.apply func context args))
          (if-not timeout (set! context nil args nil))))
    (fn []
      (with-local-vars [remaining ? now (nowMillis)])
      (if (and (not previous) (false? options.leading)) (set! previous now))
      (set! remaining (- wait (- now previous))
            args arguments
            context this)
      (cond
        (or (<= remaining 0)(> remaining wait))
        (do (clearTimeout timeout)
            (set! timeout nil
                  previous now
                  result (.apply func context args))
            (if-not timeout (set! context nil args nil)))
        (and (not timeout)(not= options.trailing false))
        (set! timeout (setTimeout later remaining)))
      result))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF


