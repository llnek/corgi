;; Copyright Â©  2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}
  czlab.elmo.x2d.ccsx
  (:require ["kirby" :refer :all]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pointInBox
  "Test if this point is inside this rectangle."
  [box x & [[y]]
  (with-local-vars [[px py] (if-not (number? y) [x.x x.y] [x y])])
  (and (>= px box.left)(<= px box.right)(>= py box.bottom)(<= py box.top))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn collide?
   "Test collision of 2 entities using cc-rects.  Each entity
   wraps a sprite object."
  [a b]
  (if (and (some? a)
           (some? b))
    (cond
      (and a.sprite b.sprite) (collide a.sprite b.sprite)
      (and (inst? cc/Sprite a)
           (inst? cc/Sprite b)) (collide (rect a)(rect b))
      (and (number? a.width)
           (number? b.width)) (cc/rectIntersectsRect a b)
      (and (number? a.top)
           (number? b.top)) (collide a b))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setdr
  "Set device resolution, policy and orientation."
  [landscape? n1 n2 policy]
  (if landscape?
    (.setDesignResolutionSize cc/view n1 n2 policy)
    (.setDesignResolutionSize cc/view n2 n1 policy)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn portrait?
  "Test if the screen is oriented vertically."
  [] (if-some [s (screenSize)] (> s.height s.width)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn outOfBound?
  "Test if this entity is out of bound."
  [ent & [B]]
  (if ent (elmo/outOfBound (bbox4 ent.sprite) (or B (vbox)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn undoTimer
  "Maybe release this timer."
  [par timer]
  (if (and cc/sys.isNative (some? timer)) (.release timer)) nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createTimer
  "Create a timer action."
  [par timer]
  (with-local-vars [ret (.runAction par (new cc/DelayTime timer))])
  (if cc/sys.isNative (.retain ret))
  ret)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn timerDone?
  "Test if this timer is done."
  [timer] (if (and timer (.isDone timer))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createSpriteFromFrameName
  "Create a sprite from its frame name." [name] (new cc/Sprite name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn bbox4
  "Create a 4 point rectangle from this sprite."
  [sprite]
  `{:bottom (getBottom sprite)
    :top (getTop sprite)
    :left (getLeft sprite)
    :right (getRight sprite) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn runScene "" [ns & [delay]]
  (.runScene cc/director (new cc/TransitionCrossFade (opt?? delay 0.6) ns)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn isTransitioning? "" []
  (inst? cc/TransitionScene (.getRunningScene cc/director)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn csize
  "Find size of this sprite."
  [frame] (.getContentSize (createSpriteFromFrameName frame)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn halfHW
  "Calculate halves of width and height of this sprite."
  [sprite]
  (with-local-vars
    [z (.getContentSize sprite)]) [(* 0.5 z.width) (* 0.5 z.height)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn rect
  "Create a rectangle from this sprite." [sprite]
  (cc/rect (getLeft sprite) (getBottom sprite) (getWidth sprite) (getHeight sprite)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn bbox4b4
   "Create a rect from the last frame."
  [ent]
  `{:bottom (getLastBottom ent)
    :top (getLastTop ent)
    :left (getLastLeft ent)
    :right (getLastRight ent) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getScaledHeight
  "Get the scaled height."
  [sprite] (if sprite (* (getHeight sprite) (.getScaleY sprite))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getHeight
  "Get the height." [sprite] (if sprite (.-height (.getContentSize sprite)) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getScaledWidth
  "Get the scaled width."
  [sprite] (if sprite (* (getWidth sprite) (.getScaleX sprite))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getWidth
  "Get the width." [sprite] (if sprite (.-width (.getContentSize sprite)) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getLeft
  "Get the left pos."
  [sprite] (- (.-x (.getPosition sprite)) (* 0.5 (getWidth sprite))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getRight
  "Get the right pos."
  [sprite] (+ (.-x (.getPosition sprite)) (* 0.5 (getWidth sprite))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getTop
  "Get the top pos."
  [sprite] (+ (.-y (.getPosition sprite)) (* 0.5 (getHeight sprite))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getBottom
  "Get the bottom pos."
  [sprite] (- (.-y (.getPosition sprite)) (* 0.5 (getHeight sprite))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getLastLeft
  "Maybe get the previous left pos."
  [ent]
  (if-some [p ent.lastPos]
    (- p.x (* 0.5 (getWidth ent.sprite))) (getLeft ent)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getLastRight
  "Maybe get the previous right pos."
  [ent]
  (if-some [p ent.lastPos]
    (+ p.x (* 0.5 (getWidth ent.sprite))) (getRight ent)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getLastTop
  "Maybe get the previous top pos."
  [ent]
  (if-some [p ent.lastPos]
    (+ p.y (* 0.5 (getHeight ent.sprite))) (getTop ent)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getLastBottom
  "Maybe get the previous bottom pos."
  (if-some [p ent.lastPos]
    (- p.y (* 0.5 (getHeight ent.sprite))) (getBottom ent)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn centerX
  "Get the x pos of the center of the visible screen." [] (.-x (center)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn centerY
  "Get the y pos of the center of the visible screen." [] (.-y (center)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn center
  "Get the center of the visible screen."
  []
  (with-local-vars [rc (vrect)])
  (cc/p (+ rc.x (* 0.5 rc.width)) (+ rc.y (* 0.5 rc.height))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn screenHeight
  "Get the screen height." [] (.-height (screenSize)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn screenWidth
  "Get the screen width." [] (.-width (screenSize)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vrect
  "Get the visible screen rectangle."
  []
  (with-local-var [vo (.getVisibleOrigin cc/view)
                   wz (.getVisibleSize cc/view)])
  (cc/rect vo.x vo.y wz.width wz.height))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vbox
  "Get the visible screen box."
  (with-local-vars [r (vrect)])
  `{:bottom r.y
    :left r.x
    :right (+ r.x r.width)
    :top (+ r.y r.height) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn screenSize
  "Get the actual window/frame size."
  [] (if cc/sys.isNative
       (.getFrameSize cc/view) (.getWinSize cc/director)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn screenCenter
  "Get the actual screen center."
  []
  (with-local-vars [s (screenSize)])
  (cc/p (* 0.5 s.width) (* 0.5 s.height)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vboxMID
  "Get the center of this box."
  [box]
  (cc/p (+ box.left (* 0.5 (- box.right box.left)))
        (+ box.bottom (* 0.5 (- box.top box.bottom)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn traceEnclosure
  "Test if this box is hitting boundaries.
  rect.x & y are center positioned.
  If hit, the new position and velocities are returned."
  [rect vel dt B]
  (with-local-vars [vx vel.x vy vel.y hit? #t
                    sh (* 0.5 rect.height)
                    sw (* 0.5 rect.width)
                    y (+ rect.y (* dt vel.y))
                    x (+ rect.x (* dt vel.x))])
  (cond (> (+ y sh) B.top)
        (set! y (- B.top sh) vy -vy)
        (< (- y sh) B.bottom)
        (set! y (+ B.bottom sh) vy -vy) :else (false! hit?))
  (cond (> (+ x sw) B.right)
        (set! x (- B.right sw) vx -vx)
        (< (- x sw) B.left)
        (set! x (+ B.left sw) vx -vx) :else (false! hit?))
  [hit? x y vx vy])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getSpriteFromCache
  "Get the sprite from the frame cache using its id (e.g. #ship)."
  [frameid] (.getSpriteFrame cc/spriteFrameCache frameid))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hasKeyPad? "" []
  (and (not cc/sys.isNative)
       (some? (get cc/sys.capabilities :keyboard))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn onKeyPolls "" [kb]
  (when (hasKeyPad?)
    (->> `{:onKeyPressed #(aset kb %1 #t)
           :onKeyReleased #(aset kb %1 #f)
           :event cc/EventListener.KEYBOARD } (.addListener cc/eventManager))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn onKeys "" [bus]
  (when (hasKeyPad?)
    (->> `{:onKeyPressed #(.fire bus "key.down" %2)
           :onKeyReleased #(.fire bus "key.up" %2)
           :event cc/EventListener.KEYBOARD } (.addListener cc/eventManager))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hasMouse? "" []
  (and (not cc/sys.isNative)
       (some? (get cc/sys.capabilities :mouse))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn onMouse "" [bus]
  (when (hasMouse?)
    (->> `{:onMouseMove #(if (= (.getButton %) cc/EventMouse.BUTTON_LEFT)
                            (.fire bus "mouse.move" %))
           :onMouseDown #(.fire bus "mouse.down" %)
           :onMouseUp #(.fire bus "mouse.up" e)
           :event cc/EventListener.MOUSE } (.addListener cc/eventManager))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hasTouch? "" []
  (and cc/sys.isNative
       (some? (get cc/sys.capabilities :touches))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn onTouchAll "" [bus]
  (when (hasTouch?)
    (->> `{:event cc/EventListener.TOUCH_ALL_AT_ONCE
           :prevTouchId -1
           :onTouchesBegan #(true)
           :onTouchesEnded #(.fire bus
                                   "touch.all.end"
                                   `{:event e
                                     :loc (.getLocation (_1 ts)) })
           :onTouchesMoved #(let [t0 (_1 %1) id (.-id t0)]
                              (if (not= this.prevTouchId id)
                                (oset! this :prevTouchId id)
                                (.fire bus
                                       "touch.all.move"
                                       `{:event %2
                                         :delta (.getDelta t0)}))) }
         (.addListener cc/eventManager))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn onTouchOne "" [bus]
  (when (hasTouch?)
    (->> `{:event cc/EventListener.TOUCH_ONE_BY_ONE
           :swallowTouches true
           :onTouchBegan #(true)
           :onTouchMoved #(.fire bus
                                 "touch.one.move"
                                 `{:event %2
                                   :delta (.getDelta %1)
                                   :loc (.getLocation %1)})
           :onTouchEnded #(.fire bus
                                 "touch.one.end"
                                 `{:event %2
                                   :loc (.getLocation %1)}) }
         (.addListener cc/eventManager))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const *anchors*
       `{:Center (cc/p 0.5 0.5)
         :Top (cc/p 0.5 1)
         :TopRight (cc/p 1 1)
         :Right (cc/p 1 0.5)
         :BottomRight (cc/p 1 0)
         :Bottom (cc/p 0.5 0)
         :BottomLeft (cc/p 0 0)
         :Left (cc/p 0 0.5)
         :TopLeft (cc/p 0 1) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn textMenu
  "Create a text menu containing this set of items.
  Each item has the form."
  [items & [options]]
  (with-local-vars [t 1 menu (new cc/Menu)])
  (set! options (opt?? options `{}))
  (doseq [obj items :let [mi ?]]
    (set! mi (new cc/MenuItemLabel
                  (new cc/LabelBMFont
                       obj.text obj.font) obj.select obj.target))
    (.setScale mi (or options.scale 1))
    (.setTag mi t)
    (++ t)
    (.addChild menu mi)) menu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn textMenu1
  "Make a text label menu containing one single button."
  [item & [options]]
  (with-local-vars [menu (textMenu [item] options)])
  (set! options (opt?? options `{}))
  (if options.anchor (.setAnchorPoint menu options.anchor))
  (if options.pos (.setPosition menu options.pos))
  (if (false? options.visible?) (.setVisible menu false))
  (.alignItemsVertically menu)
  menu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vmenu
  "Create a vertically aligned menu with graphic buttons."
  [items & [options]]
  (with-local-vars [menu (grfxMenu #t items options)])
  (set! options (opt?? options `{}))
  (if options.pos
    (.setPosition menu options.pos)) menu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hmenu
  "Create a horizontally aligned menu with graphic buttons."
  [items & [options]]
  (with-local-vars [menu (grfxMenu #f items options)])
  (set! options (opt?? options `{}))
  (if options.pos
    (.setPosition menu options.pos)) menu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn grfxMenu
  "Create a menu with graphic buttons."
  [vertical? items & [options]]
  (with-local-vars [t 1 menu (new cc/Menu)])
  (set! options (opt?? options `{}))
  (doseq [obj items :let [mi ?]]
    (set! mi
          (new cc/MenuItemSprite
               (new cc/Sprite obj.nnn)
               (new cc/Sprite (or obj.sss obj.nnn))
               (new cc/Sprite (or obj.ddd obj.nnn))
               obj.select
               obj.target))
    (if obj.color (.setColor mi obj.color))
    (if options.scale (.setScale mi scale))
    (.setTag mi t)
    (++ t)
    (.addChild menu mi))
  padding = padding || 10;
  (if-not vertical?
    (.alignItemsHorizontallyWithPadding menu
                                        (opt?? options.padding 10))
    (.alignItemsVerticallyWithPadding menu
                                      (opt?? options.padding 10)))
  menu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn grfxMenu1
  "Create a single button menu."
  [item & [options]]
  (with-local-vars [menu (grfxMenu [item] options)])
  (set! options (opt?? options `{}))
  (if options.anchor (.setAnchorPoint menu options.anchor))
  (if options.pos (.setPosition menu options.pos))
  (if (false? options.visible?) (.setVisible menu #f))
  menu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn bmfLabel
  "Create a BMFont Label."
  [text font & [options]]
  (with-local-vars [f (new cc/LabelBMFont text font)])
  (set! options (opt?? options `{}))
  (if options.color (.setColor f options.color))
  (if options.pos (.setPosition f options.pos))
  (if options.anchor (.setAnchorPoint f options.anchor))
  (if (false? options.visible?) (.setVisible f #f))
  (.setScale f (or options.scale 1))
  f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sprite "" [key] (sprite* (getCfgImage key)))
(defn sprite* "" [path] (new cc/Sprite path))
(defn nilfunc "" [& xs])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn misprite "" [nnn & [sss ddd select target]]
  (new cc/MenuItemSprite
       (sprite nnn)
       (sprite (or sss nnn))
       (sprite (or ddd nnn)) (or select nilfunc) target))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mitoggle "" [on off cb]
  (new cc/MenuItemToggle on off cb))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;EOF

