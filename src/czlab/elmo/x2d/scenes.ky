;; Copyright Â©  2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.elmo.x2d.scenes)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- SEED 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XLive cc/Sprite
  `{ctor (fn [img x y & [scale]]
           (._super this img)
           (if (number? scale)
             (.setScale this scale))
           (.setPosition this x y)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XHUDLives cc/Class
  `{reduce (fn [x]
             (dotimes [n x]
               (.removeIcon @@hud (_1 (pop! @@icons))))
             (-= @@lives x))
    isDead #(< @@lives 0)
    getLives #(@@lives)
    reset (fn [] (let [me this]
                   (each #(.removeIcon me.hud %) @@icons)
                   (oset! this :lives @@totalLives :icons [])))
    resurrect (fn [] (.reset this) (.drawLives this))
    drawLives (fn []
                (with-local-vars
                  [y (- this.topLeft.y (* 0.5 this.lifeSize.height))
                   x (+ this.topLeft.x (* 0.5 this.lifeSize.width))
                   v ? gap 2])
                (dotimes [n @@lives]
                  (set! v (new XLive n x y))
                  (conj! @@icons v)
                  (.addIcon @@hud v)
                  (if (pos? this.options.dir)
                    (+= x (+ gap this.lifeSize.width))
                    (-= x (- this.lifeSize.width gap)))))
    create (fn []
             (with-local-vars [dummy (new XLive n 0 0)])
             (oset! this
                    :lifeSize (cc/size (ccsx/getScaledWidth dummy)
                                       (ccsx/getScaledHeight dummy)))
             (.drawLives this))
    ctor (fn [hud x y info]
           (oset! this
                  :icons []
                  :hud hud
                  :lives -1
                  :topLeft (cc/p x y)
                  :direction (opt?? info.dir 1))
           (.reset this)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XLayer cc/Layer
  `{regoSSheet (fn [sheet z tag]
                 (with-local-vars [a (new cc/SpriteBatchNode
                                          (.addImage cc/textureCache sheet))])
                 (.addChild this
                            a
                            (opt?? z @@lastZix) (opt?? tag (++ @@lastTag)))
                 (oset! this.ssheets sheet a) a)
    setup #()
    pkInput #()})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAudioIcon "" [node onKey offKey & [options]]
  (with-local-vars [off (misprite offKey)
                    on (misprite onKey)
                    audio ? menu ? wb (vbox)])
  (set! options (opt?? options `{}))
  (when (def? options.color)
    (.setColor off options.color)
    (.setColor on options.color))
  (when (def? options.scale)
    (.setScale off options.scale)
    (.setScale on options.scale))
  (set! audio
        (mitoggle on off #(toggleSfx (zero? (.getSelectedIndex %)))))
  (if (def? options.anchor)
    (.setAnchorPoint audio options.anchor))
  (.setSelectedIndex audio (if (sfxOpen?) 0 1))
  (set! menu (new cc/Menu audio))
  (if (def? options.pos)
    (.setPosition menu options.pos))
  (.addItem node menu) node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn onQuit "" [starter]
  (.pushScene cc/director
              (yesno `{no #(.popScene cc/director)
                       yes #(do->nil (.popToRootScene cc/director)
                                     (ccsx/runScene (starter))) })))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addSSheetImage
  "" [node ssheet frame & [x y]]
  (with-local-vars [bg (sprite* frame)])
  (if (def? x)
    (.setPosition bg x y))
  (if-some [s (.getChildByName node ssheet)]
    (.addChild s bg)
    (.addChild node bg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addImage
  "" [node frame & [x y]]
  (with-local-vars [s (sprite* frame)])
  (if (def? x) (.setPosition s x y)) (.addChild node s))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeSSheetAll "" [node ssheet]
  (if-some [s (.getChildByName node ssheet)] (.removeAllChildren s true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeSSheetItem
  "" [node ssheet n] (if n (.removeFromParent n true)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeAll "" [node] (.removeAllChildren node))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeChild "" [node c] (if c (.removeFromParent c)))

  addAtlasItem(atlas, n, zx, tag) {
    let p= this.getAtlas(atlas),
    pzx = zx,
    ptag = tag;

    if (! sjs.echt(pzx)) {
      pzx = this.lastZix;
    }

    if (! sjs.echt(ptag)) {
      ptag = ++this.lastTag;
    }

    if (p instanceof cc.SpriteBatchNode &&
        n instanceof cc.Sprite) {
      n.setBatchNode(p);
    }

    p.addChild(n, pzx, ptag);
  },

  /**
   * Add a child.
   * @memberof module:zotohlab/asx/scenes~XLayer
   * @method addChild
   * @param {Object} n - child
   * @param {Number} zx
   * @param {Number} tag
   */
  addItem(n,zx,tag) {
    let pzx = zx,
    ptag = tag;

    if (! sjs.echt(pzx)) {
      pzx = this.lastZix;
    }

    if (! sjs.echt(ptag)) {
      ptag = ++this.lastTag;
    }

    this.addChild(n, pzx, ptag);
  },
  /**
   * @memberof module:zotohlab/asx/scenes~XLayer
   * @method incIndexZ
   * @param {cc.Scene} par
   */
  incIndexZ() {
    ++this.lastZix;
  },
  /**
   * Remember the parent scene object.
   * @memberof module:zotohlab/asx/scenes~XLayer
   * @method setParentScene
   * @param {cc.Scene} par
   */
  setParentScene(par) {
    this.ptScene=par;
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XLayer
   * @method scene
   * @return {cc.Scene}
   */
  scene() {
    return ptScene;
  },

  /**
   * Init.
   * @memberof module:zotohlab/asx/scenes~XLayer
   * @method init
   */
  init() {
    this._super();
    this.setup();
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XLayer
   * @method ctor
   * @param {Object} options
   */
  ctor(options) {
    this.options = options || {};
    this._super();
    this.lastTag= 0;
    this.lastZix= 0;
    this.atlases= {};
  }

});

/**
 * @extends module:zotohlab/asx/scenes~XLayer
 * @class XMenuLayer
 */
const XMenuLayer= XLayer.extend({
  /**
   * @memberof module:zotohlab/asx/scenes~XMenuLayer
   * @method rtti
   * @return {String}
   */
  rtti() { return 'XMenuLayer'; },
  /**
   * @memberof module:zotohlab/asx/scenes~XMenuLayer
   * @method mkBackQuit
   * @protected
   */
  mkBackQuit(vert, btns, posfn) {
    let sz, menu;
    if (vert) {
      menu = ccsx.vmenu(btns);
    } else {
      menu= ccsx.hmenu(btns);
    }
    sz= menu.getChildren()[0].getContentSize();
    if (posfn) {
      posfn(menu, sz);
    }
    this.addItem(menu);
  },
  /**
   * @memberof module:zotohlab/asx/scenes~XMenuLayer
   * @method mkAudio
   * @protected
   */
  mkAudio(options) {
    this.addAudioIcon(options);
  }
});

//////////////////////////////////////////////////////////////////////////////
/**
 * @extends XLayer
 * @class XGameHUDLayer
 */
const XGameHUDLayer = XLayer.extend({

  /**
   * Get the id.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method rtti
   * @return {String}
   */
  rtti() { return 'HUD'; },

  /**
   * Remove this icon.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method removeIcon
   * @param {Object} icon
   */
  removeIcon(icon) {
    this.removeAtlasItem(this.hudAtlas(), icon);
  },

  /**
   * Add an icon.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method addIcon
   * @param {Object} icon
   * @param {Number} z
   * @param {Number} idx
   */
  addIcon(icon, z, idx) {
    this.addAtlasItem(this.hudAtlas(), icon, z, idx);
  },

  hudAtlas() {
    return this.atlasId;
  },

  /**
   * @protected
   */
  setup() {
    //this._super();
    this.atlasId = this.options.hudAtlas || 'game-pics';
    this.scoreLabel = null;
    this.lives= null;
    this.score= 0;
    this.replayBtn = null;

    this.initAtlases();
    this.initIcons();
    this.initLabels();
    this.initCtrlBtns();
  },

  initAtlases: sjs.NILFUNC,
  initIcons: sjs.NILFUNC,
  initLabels: sjs.NILFUNC,

  /**
   * @protected
   */
  initCtrlBtns() {
    let opts = this.options.i_replay;

    if (!!opts) {
      this.addReplayIcon(ccsx.pmenu1(opts), opts.where);
    }

    opts= this.options.i_menu;
    if (!!opts) {
      this.addMenuIcon(ccsx.pmenu1(opts), opts.where);
    }
  },

  /**
   * Get the score.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method getScore
   * @return {Number}
   */
  getScore() { return this.score; },
  /**
   * Reset the HUD as a new game.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method resetAsNew
   */
  resetAsNew() {
    this.reset();
  },
  /**
   * Reset the HUD.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method reset
   */
  reset() {
    this.disableReplay();
    this.score= 0;
    if (this.lives) {
      this.lives.resurrect();
    }
  },

  /**
   * Reduce x amount of lives.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method reduceLives
   * @param {Number} x
   * @return {Boolean} - true if no more lives.
   */
  reduceLives(x) {
    this.lives.reduce(x);
    return this.lives.isDead();
  },

  /**
   * Update the score.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method updateScore
   * @param {Number}
   */
  updateScore(num) {
    this.score += num;
    this.scoreLabel.setString(Number(this.score).toString());
  },

  /**
   * Disable the replay button.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method disableReplay
   */
  disableReplay() {
    this.replayBtn.setVisible(false);
  },

  /**
   * Enable the replay button.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method enableReplay
   */
  enableReplay() {
    this.replayBtn.setVisible(true);
  },

  /**
   * Add the main menu icon.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method addMenuItem
   * @param {cc.Menu} menu
   * @param {Object} where
   */
  addMenuIcon(menu, where) {
    let c= menu.getChildByTag(1),
    hh = ccsx.getScaledHeight(c) * 0.5,
    hw = ccsx.getScaledWidth(c) * 0.5,
    wz= ccsx.vbox(),
    x,y;

    if (where === ccsx.acs.Bottom) {
      y = wz.bottom + csts.TILE  + hh;
    } else {
      y = wz.top - csts.TILE - hh;
    }
    menu.setPosition(wz.right - csts.TILE - hw, y);
    this.addItem(menu);
  },
  /**
   * Add a replay icon.
   * @memberof module:zotohlab/asx/scenes~XGameHUDLayer
   * @method addReplayIcon
   * @param {cc.Menu} menu
   * @param {Object} where
   */
  addReplayIcon(menu, where) {
    let c= menu.getChildByTag(1),
    hh = ccsx.getScaledHeight(c) * 0.5,
    hw = ccsx.getScaledWidth(c) * 0.5,
    wz= ccsx.vbox(),
    x, y;

    if (where === ccsx.acs.Bottom) {
      y = wz.bottom + csts.TILE  + hh;
    } else {
      y = wz.top - csts.TILE  - hh;
    }
    menu.setPosition(wz.left + csts.TILE + hw, y);
    this.replayBtn=menu;
    this.addItem(menu);
  }

});

//////////////////////////////////////////////////////////////////////////////
/**
 * @extends XLayer
 * @class XGameLayer
 */
const XGameLayer = XLayer.extend({
  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method pkInput
   * @protected
   */
  pkInput() {
    //ccsx.onKeyPolls(this.keyboard);
    //ccsx.onTouchOne(this.ebus);
    //ccsx.onMouse(this.ebus);
  },
  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method getLCfg
   * @return {Object}
   */
  getLCfg() {
    return sh.getLevelCfg(this.level);
  },
  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method signal
   * @protected
   * @param {String} topic
   * @param {Function} cb
   */
  signal(topic, cb) {
    this.ebus.on(topic,cb);
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method keyPoll
   * @protected
   * @param {Number} key
   */
  keyPoll(key){
    return this.keyboard[key];
  },
  /**
   * @method initEngine
   * @protected
   */
  initEngine(syss, fact) {
    this.engine = this.newFlow();
    if (sjs.isfunc(fact)) {
      fact(this.engine, this.options);
    }
    R.forEach( z => {
      this.engine.addSystem(new (z)(this.options), z.Priority);
    }, R.filter( x => {
      return sjs.isfunc(x);
    }, syss));
  },
  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method getEnclosureBox
   * @return {Object} rect box.
   */
  getEnclosureBox() {
    return ccsx.vbox();
    /*
    var csts = xcfg.csts,
    wz = ccsx.vrect();
    return { top: wz.height - csts.TILE,
             left: csts.TILE,
             bottom: csts.TILE,
             right: wz.width - csts.TILE };
     * */
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method setGameMode
   * @param {Number} mode
   */
  setGameMode(mode) {
    xcfg.csts.GAME_MODE=mode;
  },

  /**
   * Reset and create new Ash Engine.
   *
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method newFlow
   */
  newFlow() {
    return this.engine= new Ash.Engine();
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method newGame
   * @param {Number} mode
   */
  newGame(mode) {
    if (xcfg.sound.open) {
      cc.audioEngine.stopAllEffects();
      cc.audioEngine.stopMusic();
    }
    this.onNewGame(mode);
    this.scheduleUpdate();
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method setup
   * @protected
   */
  setup() {
    const m= this.options.mode;
    if (m === sh.gtypes.ONLINE_GAME ||
        m === sh.gtypes.P2_GAME ||
        m === sh.gtypes.P1_GAME) {
      this.newGame(m);
    }
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method operational
   * @return {Boolean}
   */
  operational() { return true; },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method getBackgd
   * @return {cc.Layer} - background layer
   */
  getBackgd() {
    const rc= this.ptScene.getLayers();
    return rc['BackLayer'];
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method getHUD
   * @return {cc.Layer}  the HUD layer
   */
  getHUD() {
    const rc= this.ptScene.getLayers();
    return rc['HUD'];
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method update
   */
  update(dt) {
    if (this.operational()  && !!this.engine) {
      this.engine.update(dt);
    }
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method keys
   * @return {Array}  keys
   */
  keys() { return this.keyboard; },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method rtti
   * @return {String}  id
   */
  rtti() { return 'GameLayer'; },

  /**
   * @memberof module:zotohlab/asx/scenes~XGameLayer
   * @method ctor
   * @param {Object} options
   */
  ctor(options) {
    this.ebus= ebus.reify();
    this._super(options);
    this.keyboard= [];
    this.players= [];
    this.level= 1;
    this.actor= null;
    sh.main = this;
    const vbox= ccsx.vbox();
    sjs.loggr.debug('cc.view: vbox: left: ' + vbox.left +
                    ', bottom: ' + vbox.bottom +
                    ', top: ' + vbox.top +
                    ', right: ' + vbox.right);
  }

});

//////////////////////////////////////////////////////////////////////////////
/**
 * @extends cc.Scene
 * @class XScene
 */
const XScene = cc.Scene.extend({

  /**
   * @memberof module:zotohlab/asx/scenes~XScene
   * @method getLayers
   * @return {Array}
   */
  getLayers() {
    return this.layers;
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XScene
   * @method init
   */
  init() {
    if (this._super()) {
      this.createLayers();
      return true;
    } else {
      return false;
    }
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XScene
   * @method createLayers
   */
  createLayers() {
    let a = this.lays || [],
    glptr = undef,
    rc,
    obj;
    //hold off init'ing game layer, leave that as last
    rc = R.any((proto) => {
      obj= new (proto)(this.options);
      if ( obj instanceof XGameLayer ) {
        glptr = obj;
      }
      else
      if (obj instanceof XLayer) {
        obj.init();
      }

      if (obj instanceof XLayer) {
        obj.setParentScene(this);
      }

      this.layers[ obj.rtti() ] = obj;
      this.addChild(obj);
      return false;
    }, a);

    if (a.length > 0 && rc===false ) {
      if (!!glptr) {
        glptr.init();
      }
    }
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XScene
   * @method onmsg
   * @chainable
   * @param {String} topic
   * @param {Function} cb
   * @return {cc.Scene}
   */
  onmsg(topic, cb) {
    this.ebus.on(topic, cb);
    return this;
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XScene
   * @method ctor
   * @param {Array} ls - list of layers
   * @param {Object} options
   */
  ctor(ls, options) {
    this.options = options || {};
    this._super();
    this.lays= ls || [];
    this.layers= {};
    this.ebus= ebus.reify();
  }

});

//////////////////////////////////////////////////////////////////////////////
/**
 * @class XSceneFactory
 */
class XSceneFactory extends sjs.ES6Claxx {

  /**
   * @memberof module:zotohlab/asx/scenes~XSceneFactory
   * @method reify
   * @param {Object} options
   * @return {cc.Scene}
   */
  reify(options) {
    let itemKey= 'layers',
    arr= this.layers,
    cfg;
    if (options && sjs.hasKey(options, itemKey ) &&
        sjs.isarr(options.layers)) {
      arr= options.layers;
      cfg= R.omit(itemKey, options);
    } else {
      cfg= options || {};
    }
    const scene = new XScene(arr, cfg);
    scene.init()
    return scene;
  }

  /**
   * @memberof module:zotohlab/asx/scenes~XSceneFactory
   * @method constructor
   * @param {Array} list of layers
   */
  constructor(ls) {
    super();
    this.layers= ls || [];
  }

}

/** @alias module:zotohlab/asx/scenes */
const xbox= /** @lends xbox# */{
  /**
   * @property {XMenuLayer} XMenuLayer
   */
  XMenuLayer: XMenuLayer,
  /**
   * @property {XGameHUDLayer} XGameHUDLayer
   */
  XGameHUDLayer: XGameHUDLayer,
  /**
   * @property {XGameLayer} XGameLayer
   */
  XGameLayer: XGameLayer,
  /**
   * @property {XLayer} XLayer
   */
  XLayer: XLayer,
  /**
   * @property {XLive} XLive
   */
  XLive: XLive,
  /**
   * @property {XHUDLives} XHUDLives
   */
  XHUDLives: XHUDLives,

  /**
   * @property {XSceneFactory} XSceneFactory
   */
  XSceneFactory: XSceneFactory,
  /**
   * @property {XScene} XScene
   */
  XScene: XScene,
  /**
   * @method showMenu
   */
  showMenu() {
    const dir= cc.director;
    dir.pushScene(sh.protos[sh.ptypes.mmenu].reify({
      onback() { dir.popScene(); }
    }));
  }
};

sjs.merge(exports, xbox);
/*@@
return xbox;
@@*/

//////////////////////////////////////////////////////////////////////////////
//EOF

