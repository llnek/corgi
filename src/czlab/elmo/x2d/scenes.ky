;; Copyright Â©  2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.elmo.x2d.scenes

  (:require ["Cookies" :as cks]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- SEED 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XLive cc/Sprite
  `{ctor (fn [img x y & [scale]]
           (._super this img)
           (if (number? scale)
             (.setScale this scale))
           (.setPosition this x y)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XHUDLives cc/Class
  `{reduce (fn [x]
             (dotimes [n x]
               (.removeIcon @@hud (_1 (pop! @@icons))))
             (-= @@lives x))
    isDead #(< @@lives 0)
    getLives #(@@lives)
    reset (fn [] (let [me this]
                   (each #(.removeIcon me.hud %) @@icons)
                   (oset! this :lives @@totalLives :icons [])))
    resurrect (fn [] (.reset this) (.drawLives this))
    drawLives (fn []
                (with-local-vars
                  [y (- this.topLeft.y (* 0.5 this.lifeSize.height))
                   x (+ this.topLeft.x (* 0.5 this.lifeSize.width))
                   v ? gap 2])
                (dotimes [n @@lives]
                  (set! v (new XLive n x y))
                  (conj! @@icons v)
                  (.addIcon @@hud v)
                  (if (pos? this.options.dir)
                    (+= x (+ gap this.lifeSize.width))
                    (-= x (- this.lifeSize.width gap)))))
    create (fn []
             (with-local-vars [dummy (new XLive n 0 0)])
             (oset! this
                    :lifeSize (cc/size (ccsx/getScaledWidth dummy)
                                       (ccsx/getScaledHeight dummy)))
             (.drawLives this))
    ctor (fn [hud x y info]
           (oset! this
                  :icons []
                  :hud hud
                  :lives -1
                  :topLeft (cc/p x y)
                  :direction (opt?? info.dir 1))
           (.reset this)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XLayer cc/Layer `{})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sbatch "" [key] (new cc/SpriteBatchNode (gfcImage key)))
(defn sbatch* "" [path] (new cc/SpriteBatchNode path))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAudioIcon "" [node onKey offKey & [options]]
  (with-local-vars [off (misprite offKey)
                    on (misprite onKey)
                    audio ? menu ? wb (vbox)])
  (set! options (opt?? options `{}))
  (when (def? options.color)
    (.setColor off options.color)
    (.setColor on options.color))
  (when (def? options.scale)
    (.setScale off options.scale)
    (.setScale on options.scale))
  (set! audio
        (mitoggle on off #(toggleSfx (zero? (.getSelectedIndex %)))))
  (if (def? options.anchor)
    (.setAnchorPoint audio options.anchor))
  (.setSelectedIndex audio (if (sfxOpen?) 0 1))
  (set! menu (new cc/Menu audio))
  (if (def? options.pos)
    (.setPosition menu options.pos))
  (.addItem node menu) node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn onQuit "" [starter]
  (.pushScene cc/director
              (yesno `{no #(.popScene cc/director)
                       yes #(do->nil (.popToRootScene cc/director)
                                     (ccsx/runScene (starter))) })))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeChild "" [node c]
  (when-some [t (cond
                  (string? c) (.getChildByName node c)
                  (number? c) (.getChildByTag node c)
                  (object? c) c)]
    ;(if (inst? cc/SpriteBatchNode t) (.removeAllChildren t))
    (.removeFromParent t))
  node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeAll "" [node] (if node (.removeAllChildren node)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XMenuLayer XLayer `{})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addBackQuit "" [node vert? btns posfn]
  (with-local-vars [menu (if vert?
                           (ccsx/vmenu btns) (ccsx/hmenu btns))
                    sz (-> (.getChildren menu)
                           (_1 )
                           (.getContentSize))])
  (.addChild node menu)
  node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XGameHUDLayer XLayer
  `{ctor (fn []
           (._super this)
           (oset! this
                  :scoreLabel nil
                  :lives nil :score 0 :replayBtn nil)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resetHUDLayer "" [hud]
  (toggleReplayBtn hud #f)
  (oset! hud :score 0)
  (if-some [obj hud.lives] (.resurrect obj)) hud)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reduceHUDLives "" [hud n]
  (when-some [obj hud.lives] (.reduce obj n) (.isDead obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn updateScore "" [obj value]
  (oset! obj :score (+ (get obj :score) value))
  (if-some [s obj.scoreLabel] (.setString s (numStr obj.score)))
  obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn toggleReplayBtn "" [node onoff]
  (if-some [r node.replayBtn] (.setVisible r onff)) node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XGameLayer XLayer
  `{ctor (fn []
           (._super this)
           (oset! this
                  :ebus (createEbus)
                  :keyboard []
                  :players []
                  :level 1
                  :actor nil))
    update (fn [dt]
             (if (and (get (.getParent this) :running?)
                      (some? @@engine))
               (.update @@engine dt))) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn signal "" [node topic cb]
  (if-some [bus node.ebus] (.on bus topic cb)) node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyPoll "" [node key]
  (if-some [kb node.keyboard] (aget kb key)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setGameMode "" [mode]
  (update-in! *xcfg* [:csts :game-mode] #(mode)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn newGame "" [node mode]
  (if (sfxOpen?) (sfxCancel))
  (onNewGame mode)
  (.scheduleUpdate node)
  node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setup "" [node mode] (newGame node mode))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getBackgd "" [scene] (get (.getLayers scene) "BackLayer"))
(defn getHUD "" [scene] (get (.getLayers scene) "HUD"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XScene cc/Scene `{})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn showMenu "" [menu] (.pushScene cc/director menu))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ui.js

(defcc Circle cc/Class
  `{draw (fn [ctx styleObj]
           (.beginPath ctx)
           (oset! ctx
                  :strokeStyle styleObj.stroke.style
                  :lineWidth styleObj.line.width)
           (.arc ctx @@x @@y @@radius 0 (* 2 Math/PI) #)
           (.stroke ctx))
    ctor (fn [x y radius]
           (._super this)
           (oset! this :x x :y y :radius radius)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc Line cc/Class
  `{draw (fn [ctx styleObj]
           (.beginPath ctx)
           (.moveTo ctx @@x1 @@y1)
           (.lineTo ctx @@x2 @@y2)
           (oset! ctx
                  :strokeStyle styleObj.stroke.style
                  :lineWidth styleObj.line.width)
           (if (some? styleObj.line.cap)
             (oset! ctx :lineCap styleObj.line.cap))
           (.stroke ctx))
    ctor (fn [x1 y1 x2 y2]
           (._super this)
           (oset! this :x1 x1 :y1 y1 :x2 x2 :y2 y2)) })

(defcc Point cc/Class
  `{ctor (fn [x y]
           (._super this)
           (oset! this :x x :y y)) })

(defcc Area cc/Class
  `{ctor (fn [x y width height]
           (._super this)
           (oset! this :pos (cc/p x y) :height height :width width)) })

(defcc TextStyle cc/Class
  `{ctor (fn []
           (._super this)
           (oset! this
                  :font "14px 'Architects Daughter'"
                  :fill "#dddddd" :align "left" :base "top")) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn createScore "" [name value]
  `{:value (Number (.trim value)) :name (.trim name) })

(defcc HighScores cc/Class
  `{read #(oset! this
                 :scores
                 (reduce (fn [acc z]
                            (with-local-vars [a (.split (or z "") ":")])
                            (if (= 2 (alen a))
                              (conj! acc (score* (_1 a) (_2 a)))) acc)
                          [] (.split (or (cks/get @@KEY) "") "|")))
    reset #(oset! this :scores [])
    write (fn []
            (cks/set @@key
                     (join "|" (map #(str (.-name %)
                                          ":" (-.value %)) @@scores))
                     @@duration))
    hasSlots #(< (alen @@scores) @@size)
    canAdd (fn [score]
             (if (.hasSlots this)
               #t (some #(< (.-value %) score) @@scores)))
    insert (fn [name score]
             (with-local-vars [s (score* name score)
                               len (alen @@scores)]
               (when-not (.hasSlots this)
                 (rloop [v @@scores :index i]
                   (when (< v score)
                     (.splice @@scores i 1) (break-out-of-loop!))))
               (when (.hasSlots this)
                 (conj! @@scores s)
                 (.sort this)
                 (.write this))))
    sort #(Array.prototype.sort @@scores
                                #(cond (< (.-value %1) (.-value %2)) -1
                                       (> (.-value %1) (.-value %2)) 1
                                       :else 0))
    ctor (fn [key size duration]
           (._super this)
           (oset! this
                  :duration (opt?? duration (* 60 60 24 1000))
                  :size (opt?? size 10)
                  :scores []
                  :key key)) })

(defcc Vector2 cc/Class
  `{mult #(new Vector2 0 0 (* % @@x)(* % @@y))
    rotate (fn [cx cy deg]
             (with-local-vars [rad (cc/degreesToRadians deg)])
             (oset! this
                    :x (+ cx (- (* (Math/cos rad) (- @@x cx))
                                (* (Math/sin rad) (- @@y y0))))
                    :y (+ cy (+ (* (Math/sin rad) (- @@x cx))
                                (* (Math/cos rad) (- @@y y0))))))
    length #(Math/sqrt (+ (* @@x @@x) (* @@y @@y)))
    toString #(str "[" @@x "," @@y "]")
    plus #(new Vector2 0 0 (+ @@x (.-x %)) (+ @@y (.-y %)))
    minus #(new Vector2 0 0 (- @@x (.-x %)) (- @@y (.-y %)))
    ctor (fn [x1 y1 x2 y2]
           (._super this)
           (oset! this :x (- x2 x1) :y (- y2 y1))) })

(defcc YesNoScene XScene `{})
(defcc MBoxScene XScene `{})
(defcc NetPlayScene XScene `{})



