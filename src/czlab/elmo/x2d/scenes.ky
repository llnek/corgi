;; Copyright Â©  2013-2018, Kenneth Leung. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns ^{:doc ""
      :author "Kenneth Leung"}

  czlab.elmo.x2d.scenes)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- SEED 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XLive cc/Sprite
  `{ctor (fn [img x y & [scale]]
           (._super this img)
           (if (number? scale)
             (.setScale this scale))
           (.setPosition this x y)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XHUDLives cc/Class
  `{reduce (fn [x]
             (dotimes [n x]
               (.removeIcon @@hud (_1 (pop! @@icons))))
             (-= @@lives x))
    isDead #(< @@lives 0)
    getLives #(@@lives)
    reset (fn [] (let [me this]
                   (each #(.removeIcon me.hud %) @@icons)
                   (oset! this :lives @@totalLives :icons [])))
    resurrect (fn [] (.reset this) (.drawLives this))
    drawLives (fn []
                (with-local-vars
                  [y (- this.topLeft.y (* 0.5 this.lifeSize.height))
                   x (+ this.topLeft.x (* 0.5 this.lifeSize.width))
                   v ? gap 2])
                (dotimes [n @@lives]
                  (set! v (new XLive n x y))
                  (conj! @@icons v)
                  (.addIcon @@hud v)
                  (if (pos? this.options.dir)
                    (+= x (+ gap this.lifeSize.width))
                    (-= x (- this.lifeSize.width gap)))))
    create (fn []
             (with-local-vars [dummy (new XLive n 0 0)])
             (oset! this
                    :lifeSize (cc/size (ccsx/getScaledWidth dummy)
                                       (ccsx/getScaledHeight dummy)))
             (.drawLives this))
    ctor (fn [hud x y info]
           (oset! this
                  :icons []
                  :hud hud
                  :lives -1
                  :topLeft (cc/p x y)
                  :direction (opt?? info.dir 1))
           (.reset this)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XLayer cc/Layer `{})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addSSheet "" [node sheetKey & [zOrder]]
  (with-local-vars
    [s (->> (getCfgImage sheetKey)
            (new cc/SpriteBatchNode))]) (.addChild node s zOrder sheet) node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addAudioIcon "" [node onKey offKey & [options]]
  (with-local-vars [off (misprite offKey)
                    on (misprite onKey)
                    audio ? menu ? wb (vbox)])
  (set! options (opt?? options `{}))
  (when (def? options.color)
    (.setColor off options.color)
    (.setColor on options.color))
  (when (def? options.scale)
    (.setScale off options.scale)
    (.setScale on options.scale))
  (set! audio
        (mitoggle on off #(toggleSfx (zero? (.getSelectedIndex %)))))
  (if (def? options.anchor)
    (.setAnchorPoint audio options.anchor))
  (.setSelectedIndex audio (if (sfxOpen?) 0 1))
  (set! menu (new cc/Menu audio))
  (if (def? options.pos)
    (.setPosition menu options.pos))
  (.addItem node menu) node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn onQuit "" [starter]
  (.pushScene cc/director
              (yesno `{no #(.popScene cc/director)
                       yes #(do->nil (.popToRootScene cc/director)
                                     (ccsx/runScene (starter))) })))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeChild "" [node c]
  (when-some [t (cond
                  (string? c) (.getChildByName node c)
                  (number? c) (.getChildByTag node c)
                  (object? c) c)]
    ;(if (inst? cc/SpriteBatchNode t) (.removeAllChildren t))
    (.removeFromParent t))
  node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn removeAll "" [node] (if node (.removeAllChildren node)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XMenuLayer XLayer `{})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn addBackQuit "" [node vert? btns posfn]
  (with-local-vars [menu (if vert?
                           (ccsx/vmenu btns) (ccsx/hmenu btns))
                    sz (-> (.getChildren menu)
                           (_1 )
                           (.getContentSize))])
  (.addChild node menu)
  node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XGameHUDLayer XLayer
  `{ctor (fn []
           (._super this)
           (oset! this
                  :scoreLabel nil
                  :lives nil :score 0 :replayBtn nil)) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn resetHUDLayer "" [hud]
  (toggleReplayBtn hud #f)
  (oset! hud :score 0)
  (if-some [obj hud.lives] (.resurrect obj)) hud)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reduceHUDLives "" [hud n]
  (when-some [obj hud.lives] (.reduce obj n) (.isDead obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn updateScore "" [obj value]
  (oset! obj :score (+ (get obj :score) value))
  (if-some [s obj.scoreLabel] (.setString s (numStr obj.score)))
  obj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn toggleReplayBtn "" [node onoff]
  (if-some [r node.replayBtn] (.setVisible r onff)) node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XGameLayer XLayer
  `{ctor (fn []
           (._super this)
           (oset! this
                  :ebus (createEbus)
                  :keyboard []
                  :players []
                  :level 1
                  :actor nil))
    update (fn [dt]
             (if (and (get (.getParent this) :running?)
                      (some? @@engine))
               (.update @@engine dt))) })

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn signal "" [node topic cb]
  (if-some [bus node.ebus] (.on bus topic cb)) node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyPoll "" [node key]
  (if-some [kb node.keyboard] (aget kb key)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setGameMode "" [mode]
  (update-in! *xcfg* [:csts :game-mode] #(mode)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn newGame "" [node mode]
  (if (sfxOpen?) (sfxCancel))
  (onNewGame mode)
  (.scheduleUpdate node)
  node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn setup "" [node mode] (newGame node mode))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getBackgd "" [scene] (get (.getLayers scene) "BackLayer"))
(defn getHUD "" [scene] (get (.getLayers scene) "HUD"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defcc XScene cc/Scene
  `{getLayers #(.-layers this)
    init #(if (._super this)
            (do->true (.createLayers this)) #f)
    createLayers (fn []
    let a = this.lays || [],
    glptr = undef,
    rc,
    obj;
    //hold off init'ing game layer, leave that as last
    rc = R.any((proto) => {
      obj= new (proto)(this.options);
      if ( obj instanceof XGameLayer ) {
        glptr = obj;
      }
      else
      if (obj instanceof XLayer) {
        obj.init();
      }

      if (obj instanceof XLayer) {
        obj.setParentScene(this);
      }

      this.layers[ obj.rtti() ] = obj;
      this.addChild(obj);
      return false;
    }, a);

    if (a.length > 0 && rc===false ) {
      if (!!glptr) {
        glptr.init();
      }
    }
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XScene
   * @method onmsg
   * @chainable
   * @param {String} topic
   * @param {Function} cb
   * @return {cc.Scene}
   */
  onmsg(topic, cb) {
    this.ebus.on(topic, cb);
    return this;
  },

  /**
   * @memberof module:zotohlab/asx/scenes~XScene
   * @method ctor
   * @param {Array} ls - list of layers
   * @param {Object} options
   */
  ctor(ls, options) {
    this.options = options || {};
    this._super();
    this.lays= ls || [];
    this.layers= {};
    this.ebus= ebus.reify();
  }

});

//////////////////////////////////////////////////////////////////////////////
/**
 * @class XSceneFactory
 */
class XSceneFactory extends sjs.ES6Claxx {

  /**
   * @memberof module:zotohlab/asx/scenes~XSceneFactory
   * @method reify
   * @param {Object} options
   * @return {cc.Scene}
   */
  reify(options) {
    let itemKey= 'layers',
    arr= this.layers,
    cfg;
    if (options && sjs.hasKey(options, itemKey ) &&
        sjs.isarr(options.layers)) {
      arr= options.layers;
      cfg= R.omit(itemKey, options);
    } else {
      cfg= options || {};
    }
    const scene = new XScene(arr, cfg);
    scene.init()
    return scene;
  }

  /**
   * @memberof module:zotohlab/asx/scenes~XSceneFactory
   * @method constructor
   * @param {Array} list of layers
   */
  constructor(ls) {
    super();
    this.layers= ls || [];
  }

}

/** @alias module:zotohlab/asx/scenes */
const xbox= /** @lends xbox# */{
  /**
   * @property {XMenuLayer} XMenuLayer
   */
  XMenuLayer: XMenuLayer,
  /**
   * @property {XGameHUDLayer} XGameHUDLayer
   */
  XGameHUDLayer: XGameHUDLayer,
  /**
   * @property {XGameLayer} XGameLayer
   */
  XGameLayer: XGameLayer,
  /**
   * @property {XLayer} XLayer
   */
  XLayer: XLayer,
  /**
   * @property {XLive} XLive
   */
  XLive: XLive,
  /**
   * @property {XHUDLives} XHUDLives
   */
  XHUDLives: XHUDLives,

  /**
   * @property {XSceneFactory} XSceneFactory
   */
  XSceneFactory: XSceneFactory,
  /**
   * @property {XScene} XScene
   */
  XScene: XScene,
  /**
   * @method showMenu
   */
  showMenu() {
    const dir= cc.director;
    dir.pushScene(sh.protos[sh.ptypes.mmenu].reify({
      onback() { dir.popScene(); }
    }));
  }
};

sjs.merge(exports, xbox);
/*@@
return xbox;
@@*/

//////////////////////////////////////////////////////////////////////////////
//EOF

