/*Auto generated by Kirby v1.0.0 - Sat Mar 31 2018 19:37:07 GMT-0700 (PDT)
  czlab.elmo.ecs.test
{"doc" "" "author" "Kenneth Leung"}
*/

const ky = require("kirby");
const MODULE_NAMESPACE = ky["MODULE_NAMESPACE"];
const MAX_DASH_INT = ky["MAX_DASH_INT"];
const MIN_DASH_INT = ky["MIN_DASH_INT"];
const println = ky["println"];
const not_DASH_empty = ky["not_DASH_empty"];
const stringify = ky["stringify"];
const opt_QMRK__QMRK = ky["opt_QMRK__QMRK"];
const cons_BANG = ky["cons_BANG"];
const conj_BANG = ky["conj_BANG"];
const conj = ky["conj"];
const disj_BANG = ky["disj_BANG"];
const disj = ky["disj"];
const pop_BANG = ky["pop_BANG"];
const pop = ky["pop"];
const wrap_DASH_str = ky["wrap_DASH_str"];
const getIndex = ky["getIndex"];
const getProp = ky["getProp"];
const prn = ky["prn"];
const LambdaArg = ky["LambdaArg"];
const Primitive = ky["Primitive"];
const RegexObj = ky["RegexObj"];
const Keyword = ky["Keyword"];
const Symbol = ky["Symbol"];
const primitive_QMRK = ky["primitive_QMRK"];
const primitive = ky["primitive"];
const regexObj_QMRK = ky["regexObj_QMRK"];
const regexObj = ky["regexObj"];
const symbol_QMRK = ky["symbol_QMRK"];
const symbol = ky["symbol"];
const keyword_QMRK = ky["keyword_QMRK"];
const keyword = ky["keyword"];
const keyword_DASH__GT_symbol = ky["keyword_DASH__GT_symbol"];
const lambdaArg_QMRK = ky["lambdaArg_QMRK"];
const lambdaArg = ky["lambdaArg"];
const Atom = ky["Atom"];
const atom_QMRK = ky["atom_QMRK"];
const atom = ky["atom"];
const reset_BANG = ky["reset_BANG"];
const resetVec_BANG = ky["resetVec_BANG"];
const resetMap_BANG = ky["resetMap_BANG"];
const resetSet_BANG = ky["resetSet_BANG"];
const resetObject_BANG = ky["resetObject_BANG"];
const objClass = ky["objClass"];
const sort_BANG = ky["sort_BANG"];
const deref = ky["deref"];
const swap_BANG = ky["swap_BANG"];
const typeid = ky["typeid"];
const complex_QMRK = ky["complex_QMRK"];
const simple_QMRK = ky["simple_QMRK"];
const value_QMRK = ky["value_QMRK"];
const sequential_QMRK = ky["sequential_QMRK"];
const eq_QMRK = ky["eq_QMRK"];
const object_QMRK = ky["object_QMRK"];
const last = ky["last"];
const into_BANG = ky["into_BANG"];
const into = ky["into"];
const pairs_QMRK = ky["pairs_QMRK"];
const list_QMRK = ky["list_QMRK"];
const list = ky["list"];
const vector_QMRK = ky["vector_QMRK"];
const vector = ky["vector"];
const set_QMRK = ky["set_QMRK"];
const set = ky["set"];
const map_QMRK = ky["map_QMRK"];
const obj_QMRK = ky["obj_QMRK"];
const arraymap = ky["arraymap"];
const object = ky["object"];
const seq = ky["seq"];
const rseq = ky["rseq"];
const contains_QMRK = ky["contains_QMRK"];
const nichts_QMRK = ky["nichts_QMRK"];
const some_QMRK = ky["some_QMRK"];
const count = ky["count"];
const concat_STAR = ky["concat_STAR"];
const evens = ky["evens"];
const odds = ky["odds"];
const modulo = ky["modulo"];
const partition = ky["partition"];
const split = ky["split"];
const split_DASH_str = ky["split_DASH_str"];
const interleave = ky["interleave"];
const zipmap = ky["zipmap"];
const zipobj = ky["zipobj"];
const extendAttr = ky["extendAttr"];
const cons = ky["cons"];
const gensym = ky["gensym"];
const carve = ky["carve"];
const assoc_BANG = ky["assoc_BANG"];
const dissoc_BANG = ky["dissoc_BANG"];
const truthy_QMRK = ky["truthy_QMRK"];
const falsy_QMRK = ky["falsy_QMRK"];
const flatten = ky["flatten"];
const identity = ky["identity"];
const m_DASH_identity = ky["m_DASH_identity"];
const m_DASH_maybe = ky["m_DASH_maybe"];
const m_DASH_list = ky["m_DASH_list"];
const m_DASH_state = ky["m_DASH_state"];
const m_DASH_continuation = ky["m_DASH_continuation"];
const run_DASH_cont = ky["run_DASH_cont"];
const quote_DASH_str = ky["quote_DASH_str"];
const unquote_DASH_str = ky["unquote_DASH_str"];
const escXml = ky["escXml"];
const split_DASH_seq = ky["split_DASH_seq"];
const select_DASH_keys = ky["select_DASH_keys"];
const update_DASH_in_BANG = ky["update_DASH_in_BANG"];
const get_DASH_in = ky["get_DASH_in"];
const merge = ky["merge"];
const mixin = ky["mixin"];
const fillArray = ky["fillArray"];
const copyArray = ky["copyArray"];
const difference = ky["difference"];
const inc = ky["inc"];
const dec = ky["dec"];
const percent = ky["percent"];
const toFixed = ky["toFixed"];
const mapcat = ky["mapcat"];
const ensureTest = ky["ensureTest"];
const ensureTestThrown = ky["ensureTestThrown"];
const runtest = ky["runtest"];
const pushNSP = ky["pushNSP"];
const popNSP = ky["popNSP"];
const peekNSP = ky["peekNSP"];
const _STAR_ns_STAR = ky["_STAR_ns_STAR"];
const minBy = ky["minBy"];
const maxBy = ky["maxBy"];
const take_DASH_while = ky["take_DASH_while"];
const drop_DASH_while = ky["drop_DASH_while"];
const split_DASH_with = ky["split_DASH_with"];
const ecs = require("../../../../src/czlab/elmo/ecs/core");
const kirbystdlibref = require("kirby");
const __module_namespace__ = "czlab.elmo.ecs.test";
////////////////////////////////////////////////////////////////////////////////
//fn: [compA] in file: test.ky, line: 18
const compA = function() {
  return {
    "a": 50
  };
};
////////////////////////////////////////////////////////////////////////////////
//fn: [compB] in file: test.ky, line: 19
const compB = function() {
  return {
    "b": 10
  };
};
////////////////////////////////////////////////////////////////////////////////
//fn: [compC] in file: test.ky, line: 20
const compC = function() {
  return {
    "c": 15
  };
};
const compDPool = ecs.createPool(function() {
  return {
    "d": 10
  };
}, function(x) {
  return x;
}, 8);
////////////////////////////////////////////////////////////////////////////////
//fn: [compD] in file: test.ky, line: 27
const compD = function() {
  return ecs.takeFromPool(compDPool);
};
const tmpA = {
  "components": (new Set(["c1", "c3"])),
  "initor": function() {}
};
const tmpB = {
  "components": (new Set(["c2", "c3"])),
  "initor": function() {}
};
const _STAR_ecs_STAR = ecs.createECS();
var TEMP_DASH_VAR = null;
////////////////////////////////////////////////////////////////////////////////
//fn: [sys1] in file: test.ky, line: 41
const sys1 = function(e, t) {
  return (((t > 0)) ?
    conj_BANG(TEMP_DASH_VAR, 1) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sys2] in file: test.ky, line: 42
const sys2 = function(e, t) {
  return (((t > 0)) ?
    conj_BANG(TEMP_DASH_VAR, 2) :
    null);
};
////////////////////////////////////////////////////////////////////////////////
//fn: [sys3] in file: test.ky, line: 43
const sys3 = function(e, t) {
  return (((t > 0)) ?
    conj_BANG(TEMP_DASH_VAR, 3) :
    null);
};
const pool1 = ecs.createPool(function() {
  return {
    "a": 0
  };
}, function(x) {
  return x;
}, 6);
const ecs_DASH_test = function() {
  let ____args = Array.prototype.slice.call(arguments);
  return [kirbystdlibref.ensureTest(((ecs.getPoolSize(pool1) === 0)), "pool,size=0"), kirbystdlibref.ensureTest((function() {
    let x = ecs.takeFromPool(pool1);
    let y = ecs.takeFromPool(pool1);
    let z = ecs.takeFromPool(pool1);
    return (3 === ecs.getPoolUsed(pool1));
  }).call(this), "pool,used"), kirbystdlibref.ensureTest((function() {
    let x = ecs.takeFromPool(pool1);
    let y = ecs.takeFromPool(pool1);
    let z = ecs.takeFromPool(pool1);
    ecs.returnToPool(pool1, z);
    return (5 === ecs.getPoolUsed(pool1));
  }).call(this), "pool,drop"), kirbystdlibref.ensureTest((6 === ecs.getPoolSize(pool1)), "pool,size>0"), kirbystdlibref.ensureTest((function() {
    let x = ecs.takeFromPool(pool1);
    let y = ecs.takeFromPool(pool1);
    let z = ecs.takeFromPool(pool1);
    ecs.returnToPool(pool1, x);
    return ((7 === ecs.getPoolUsed(pool1)) && (12 === ecs.getPoolSize(pool1)));
  }).call(this), "pool,grow"), kirbystdlibref.ensureTest((1 === (function() {
      ecs.addComponent(_STAR_ecs_STAR, "c1", compA);
      return count(ecs.getComponentKeys(_STAR_ecs_STAR));
    }).call(this)), "addComponent,1"), kirbystdlibref.ensureTest((3 === (function() {
      ecs.addComponent(_STAR_ecs_STAR, "c2", compB, "c3", compC);
      return count(ecs.getComponentKeys(_STAR_ecs_STAR));
    }).call(this)), "addComponent,*"), kirbystdlibref.ensureTest((2 === (function() {
      ecs.removeComponent(_STAR_ecs_STAR, "c1");
      return count(ecs.getComponentKeys(_STAR_ecs_STAR));
    }).call(this)), "removeComponent,1"), kirbystdlibref.ensureTest((0 === (function() {
      ecs.removeComponent(_STAR_ecs_STAR, "c2", "c3");
      return count(ecs.getComponentKeys(_STAR_ecs_STAR));
    }).call(this)), "removeComponent,*"), kirbystdlibref.ensureTest((4 === (function() {
      ecs.addComponent(_STAR_ecs_STAR, "c1", compA, "c2", compB, "c3", compC, "c4", compD);
      return count(ecs.getComponentKeys(_STAR_ecs_STAR));
    }).call(this)), "addComponent,**"), kirbystdlibref.ensureTest((2 === (function() {
      ecs.addTemplate(_STAR_ecs_STAR, "t1", tmpA, "t2", tmpB);
      return count(ecs.getTemplateKeys(_STAR_ecs_STAR));
    }).call(this)), "addTemplate,*"), kirbystdlibref.ensureTest((0 === (function() {
      ecs.removeTemplate(_STAR_ecs_STAR, "t1", "t2");
      return count(ecs.getTemplateKeys(_STAR_ecs_STAR));
    }).call(this)), "removeTemplate,*"), kirbystdlibref.ensureTest((2 === (function() {
      ecs.addTemplate(_STAR_ecs_STAR, "t1", tmpA, "t2", tmpB);
      return count(ecs.getTemplateKeys(_STAR_ecs_STAR));
    }).call(this)), "addTemplate,*"), kirbystdlibref.ensureTest((function() {
    let x = ecs.createEntity(_STAR_ecs_STAR, "c1", "c2", "c3");
    return (ecs.componentInEntity_QMRK(_STAR_ecs_STAR, x, "c1", "c2", "c3") && ecs.getEntityData(_STAR_ecs_STAR, x, "c1") && ecs.getEntityData(_STAR_ecs_STAR, x, "c2") && ecs.getEntityData(_STAR_ecs_STAR, x, "c3"));
  }).call(this), "createEntity,getData"), kirbystdlibref.ensureTest((function() {
    let a = ecs.findComponent(_STAR_ecs_STAR, "c1");
    let b = ecs.findComponent(_STAR_ecs_STAR, "c2");
    let c = ecs.findComponent(_STAR_ecs_STAR, "c3");
    let d = ecs.findComponent(_STAR_ecs_STAR, "xxx");
    return (a && b && c && nichts_QMRK(d));
  }).call(this), "engine,find"), kirbystdlibref.ensureTest((function() {
    let x = ecs.createTemplateEntity(_STAR_ecs_STAR, "t2");
    return (ecs.componentInEntity_QMRK(_STAR_ecs_STAR, x, "c2", "c3") && nichts_QMRK(ecs.getEntityData(_STAR_ecs_STAR, x, "c1")) && ecs.getEntityData(_STAR_ecs_STAR, x, "c2") && ecs.getEntityData(_STAR_ecs_STAR, x, "c3"));
  }).call(this), "createTemplateEntity,getData"), kirbystdlibref.ensureTest((function() {
    let x = ecs.createTemplateEntity(_STAR_ecs_STAR, "t1");
    let y = ecs.getEntityData(_STAR_ecs_STAR, x, "c3");
    let _ = ecs.removeEntity(_STAR_ecs_STAR, x);
    let z = ecs.getEntityData(_STAR_ecs_STAR, x, "c1");
    return (some_QMRK(y) && nichts_QMRK(z));
  }).call(this), "removeEntity"), kirbystdlibref.ensureTest((function() {
    let x = ecs.createEntity(_STAR_ecs_STAR, "c4");
    let ok = (ecs.componentInEntity_QMRK(_STAR_ecs_STAR, x, "c4") && ecs.getEntityData(_STAR_ecs_STAR, x, "c4"));
    ecs.removeEntity(_STAR_ecs_STAR, x);
    return (ok && (!ecs.componentInEntity_QMRK(_STAR_ecs_STAR, x, "c4")));
  }).call(this), "createEntity,pooled"), kirbystdlibref.ensureTest(ky.eq_QMRK([1, 2, 3], (function() {
    (
    TEMP_DASH_VAR = []);
    ecs.addSystem(_STAR_ecs_STAR, sys1, sys2, sys3);
    ecs.updateECS(_STAR_ecs_STAR, 10);
    return TEMP_DASH_VAR;
  }).call(this)), "engine,addSystem")];
};
println(runtest(ecs_DASH_test, "test: ecs"));
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.elmo.ecs.test",
    vars: ["ecs-test"],
    macros: {}
  },
  ecs_DASH_test: ecs_DASH_test
};